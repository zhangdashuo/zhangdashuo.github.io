<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张硕&#39;s Blogs</title>
  <icon>https://www.gravatar.com/avatar/3cc7777481bcedc89f40e0f878d22841</icon>
  <subtitle>因为有了危机感，所以会义无反顾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangdashuo.github.io/"/>
  <updated>2018-11-15T10:57:06.919Z</updated>
  <id>https://zhangdashuo.github.io/</id>
  
  <author>
    <name>业余Linux管理员</name>
    <email>2292650292@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一种内网资源分享方式</title>
    <link href="https://zhangdashuo.github.io/2018/11/15/intranetuse/"/>
    <id>https://zhangdashuo.github.io/2018/11/15/intranetuse/</id>
    <published>2018-11-15T02:43:29.000Z</published>
    <updated>2018-11-15T10:57:06.919Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 一种内网资源分享方式：</strong> <excerpt in="" index="" |="" 首页摘要=""><br> 通过Discuz，nextcloud，和Empirecms实现校园网资源共享<br><a id="more"></a></excerpt></p><h2 id=""><a href="#" class="headerlink" title=""></a><the rest="" of="" contents="" |="" 余下全文=""></the></h2><p>最近一直在忙校园网资源共享，今天做个总结，主要介绍利用Discuz，Empirecms，Nextclous来实现共享的方式，和如何使用这三个软件实现校园生活交流和资源共享。在网页中如果要插入一张图片可以通过取得该图片的绝对网络地址，来使用标签进行调用，这里使用相同的方式。即利用Nextcloud云盘为上传的所有文件提供绝对网络地址，然后通过交互式的平台这里利用Discuz和Empirecms来实现资源的展示。</p><h2 id="Nextcloud使用方式的介绍"><a href="#Nextcloud使用方式的介绍" class="headerlink" title="Nextcloud使用方式的介绍"></a>Nextcloud使用方式的介绍</h2><p><a href="http://10.5.42.14/" target="_blank" rel="noopener">登录网盘点击这里(需要连接航大校园网)</a></p><p>Nextcloud是一个国外的开源云网盘项目，它的前身是owncloud，Nextcloud相对owncloud功能更强大和具有更高的稳定性，所以这里采用的是Nextcloud来作为内网网盘和提供一系列共享方式。并通过在Nextcloud上传的文件获得该文件的URL。通过URL便可以在Discuz和Empirecms实现展示。</p><h3 id="如何注册Nextcloud账户"><a href="#如何注册Nextcloud账户" class="headerlink" title="如何注册Nextcloud账户"></a>如何注册Nextcloud账户</h3><p>在浏览器中输入<a href="http://10.5.42.14(需要连接航大校园网)或是登录论坛网址http://10.5.42.11(需要连接航大校园网)在论坛的导航页面即可看到网盘的登录入口。" target="_blank" rel="noopener">http://10.5.42.14(需要连接航大校园网)或是登录论坛网址http://10.5.42.11(需要连接航大校园网)在论坛的导航页面即可看到网盘的登录入口。</a></p><p>登录入口如下所示：</p><p><img src="/2018/11/15/intranetuse/nextcloudlogo.jpg" alt=""></p><p>然后点击注册选项按着提示输入注册信息即可进行账号的注册，但是注意！每个账号注册之后默认空间为10G，如果有需要更大的空间的可以和我联系。</p><h3 id="如何使用Nextcloud"><a href="#如何使用Nextcloud" class="headerlink" title="如何使用Nextcloud"></a>如何使用Nextcloud</h3><p>登录Nextcloud如下图所示：</p><p><img src="/2018/11/15/intranetuse/nextcloudfiles.jpg" alt=""></p><p>该网盘和百度云网盘的使用大致相同，界面为中文使用起来还是比较方便的。</p><h4 id="使用Nextcloud分享文件"><a href="#使用Nextcloud分享文件" class="headerlink" title="使用Nextcloud分享文件"></a>使用Nextcloud分享文件</h4><p>其实Nextcloud可以实现公司内部文件共享的各种高级方式，这里就不介绍那么多，只介绍最简单的文件分享。例如我要对Nextcloud.mp4进行文件的共享可以点击共享按钮，如下图所示：</p><p><img src="/2018/11/15/intranetuse/fenxiang.jpg" alt=""></p><p>点击分享按钮之后会弹出如下的窗口：</p><p><img src="/2018/11/15/intranetuse/1542270948.jpg" alt=""></p><p>然后点击分享链接前面的那个小方框，点击之后如下图：</p><p><img src="/2018/11/15/intranetuse/1542270976.jpg" alt=""></p><p>此时便获得分享的链接，点击右边的复制按钮便可以将链接复制到粘贴板，把这个链接发给要分享的人，在浏览器中输入该链接可以实现在线查看和下载的功能。</p><p><img src="/2018/11/15/intranetuse/1542271078.jpg" alt=""></p><p>这里是利用该网盘实现的网络共享的方式，内网文件分享还是比较方便的。</p><h4 id="使用Nextclous获得文件的外链接"><a href="#使用Nextclous获得文件的外链接" class="headerlink" title="使用Nextclous获得文件的外链接"></a>使用Nextclous获得文件的外链接</h4><p>外链接其实就是一个文件的绝对网络位置，利用该链接可以访问到文件的方式。下面介绍使用Nextcloud获得存储在Nextcloud中文件的外链接，该外链接很重要，Discuz和Empirecms中需要获得该链接来实现资源的投稿。</p><p>还是以Nextcloud.mp4为例，该文件的外链接为：<a href="http://10.5.42.14/data/redhat/files/Nextcloud.mp4" target="_blank" rel="noopener">http://10.5.42.14/data/redhat/files/Nextcloud.mp4</a> 这个链接的获得方式如下：（1）Nextcloud.mp4是要分享的文件的名字。（2）<a href="http://10.5.42.14/data/redhat/files/这一段为用户的根目录。（3）不同的用户只需要将/files/前面的用户名换成自己的即可。再比如获得Photos/Nut.jpg文件的外链接为：" target="_blank" rel="noopener">http://10.5.42.14/data/redhat/files/这一段为用户的根目录。（3）不同的用户只需要将/files/前面的用户名换成自己的即可。再比如获得Photos/Nut.jpg文件的外链接为：</a></p><p><a href="http://10.5.42.14/data/redhat/files/Photos/Nut.jpg。在强调一次这个外链接很重要。获取完外链接记得测试一下，测试的方法是将做好的外链接输入到浏览器中如果可以显示则外链接就是对的。Nut.jpg的外链接的查看如下：" target="_blank" rel="noopener">http://10.5.42.14/data/redhat/files/Photos/Nut.jpg。在强调一次这个外链接很重要。获取完外链接记得测试一下，测试的方法是将做好的外链接输入到浏览器中如果可以显示则外链接就是对的。Nut.jpg的外链接的查看如下：</a></p><p><img src="/2018/11/15/intranetuse/1542272157.jpg" alt=""></p><h4 id="Nextcloud总结"><a href="#Nextcloud总结" class="headerlink" title="Nextcloud总结"></a>Nextcloud总结</h4><p>应用实例，比如要去打印店打印东西，带优盘进去担心中病毒，每次打印完回来都要格式化优盘很是麻烦，此时可以将要打印的文件放到这个网盘中，在打印店里不用登录校园网认证账号就可以登录云盘进行下载。方便安全的同时还不消耗流量。</p><h2 id="论坛使用介绍"><a href="#论坛使用介绍" class="headerlink" title="论坛使用介绍"></a>论坛使用介绍</h2><p><a href="http://10.5.42.11/portal.php" target="_blank" rel="noopener">登录论坛点击这里(需要连接航大校园网)</a></p><p>论坛的首页如下所示：</p><p><img src="/2018/11/15/intranetuse/1542274044.jpg" alt=""></p><p>该论坛是基于Discuz_x3.3版本的，多以和以前的OB以及市面上大部分论坛类似。至于如何发帖这里就不介绍了。大部分论坛都是文字形式的列表，我把它改成这种图片形式列表，这样的展示效果更直观。</p><h3 id="以前OB共享资源的方式介绍"><a href="#以前OB共享资源的方式介绍" class="headerlink" title="以前OB共享资源的方式介绍"></a>以前OB共享资源的方式介绍</h3><p>以前的OB是基于P2P技术，通过种子进行文件的分享，这中方式的好处是随着下载人数的增多而下载速度会越来越快，但是这种方式的缺点就是需要提供种子的计算机要一直保持开机。该论坛也支持这种方式，关于如何通过该论坛制作种子在论坛中有所说明。<a href="http://10.5.42.11/forum.php?mod=viewthread&amp;tid=3" target="_blank" rel="noopener">点击这里查看种子制作教程(需要连接航大校园网)</a>。</p><h3 id="可以在线展示的资源共享方式"><a href="#可以在线展示的资源共享方式" class="headerlink" title="可以在线展示的资源共享方式"></a>可以在线展示的资源共享方式</h3><p>对于种子分享的电影文件，如果想查看还需要进行下载，所以这里提供一种可以在线播放的方式。这种方式是基于上传文件到Nextcloud来实现的。</p><p>在线视频播放我才用的是html5的视频标签来实现的。在发帖时点击MP4图标然后插入用Nextcloud生成的文件的外链接即可实现在线播放：如下所示：<img src="/2018/11/15/intranetuse/1542275312.jpg" alt=""></p><p>点击MP4的那个图标按钮，然后在弹出的窗中放入视频的Nextcloud生成的外链接，注意！一定是外链接而不是分享的链接。点击提交之后会自动生成代码如下：</p><p><img src="/2018/11/15/intranetuse/1542275337.jpg" alt=""></p><p>然后点击帖子发布即可，发布之后便可以在线观看如下所示：</p><p><img src="/2018/11/15/intranetuse/1542275387.jpg" alt=""></p><h3 id="论坛使用总结"><a href="#论坛使用总结" class="headerlink" title="论坛使用总结"></a>论坛使用总结</h3><p>对于文件的共享：</p><p>​    对于那些超大的资源建议使用种子的分享方式，对于较小的文件可以上传到Nextcloud，然后在帖子中插入分享的链接即可（注意是分享的链接，不必要使用外链接及生成URL的方式），可以在线展示也可以下载，比较方便。</p><p>对于视频的共享：</p><p>​    可以使用种子分享，也可以使用上面介绍的在线展示的方式，</p><p>发帖注意：</p><p>​    因为该论坛使用的是图片展示的形式，所以建议在发帖内容中插入展示的图片，建议展示图片大小为：260*195像素的图片。</p><h2 id="Empirecms介绍"><a href="#Empirecms介绍" class="headerlink" title="Empirecms介绍"></a>Empirecms介绍</h2><p><a href="http://10.5.42.13/" target="_blank" rel="noopener">登录Empirecms点击这里(需要连接航大校园网)</a>该网站是一个视频站点，可以让用户进行发布投稿管理员审核之后便可以进行发布。该网站首页如下所示：</p><p><img src="/2018/11/15/intranetuse/1542276431.jpg" alt=""></p><p><img src="/2018/11/15/intranetuse/1542276450.jpg" alt=""></p><h3 id="如何在该视频网站进行投稿"><a href="#如何在该视频网站进行投稿" class="headerlink" title="如何在该视频网站进行投稿"></a>如何在该视频网站进行投稿</h3><p>如果要进行投稿需要用户进行注册，点击首页的注册按钮既可以进行注册。</p><p>用户登录中心如图所示：</p><p><img src="/2018/11/15/intranetuse/1542277015.jpg" alt=""></p><p>点击红色框中的发布即可进行电影的发布。</p><p>选择要投稿的类型：</p><p><img src="/2018/11/15/intranetuse/1542277176.jpg" alt=""></p><p>例如选择要在电影里面进行投稿：</p><p><img src="/2018/11/15/intranetuse/1542277275.jpg" alt=""></p><p>如果是电影则填写在线观看地址，如果是软件或是其他文件填写下载地址即可。这里的地址填写存储在Nextcloud文件的外链接的地址即URL，注意不是分享地址。如果是电视剧的话要填写每一集的外链接地址。然后填写其他信息即可发布。待管理员审核之后则可以在网站中进行展示。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>建立这三个网站的目的是方便校园生活交流，和方便资源共享。如果有问题可以联系我。</p><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 一种内网资源分享方式：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt; 通过Discuz，nextcloud，和Empirecms实现校园网资源共享&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Discuz" scheme="https://zhangdashuo.github.io/tags/Discuz/"/>
    
      <category term="empirecms" scheme="https://zhangdashuo.github.io/tags/empirecms/"/>
    
      <category term="nextcloud" scheme="https://zhangdashuo.github.io/tags/nextcloud/"/>
    
  </entry>
  
  <entry>
    <title>ngrok内网穿透</title>
    <link href="https://zhangdashuo.github.io/2018/10/23/ngrokser/"/>
    <id>https://zhangdashuo.github.io/2018/10/23/ngrokser/</id>
    <published>2018-10-23T09:34:48.000Z</published>
    <updated>2018-10-24T03:15:43.596Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> ngrok内网穿透：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>通过ngrok实现外网I访问内网web服务器<br><a id="more"></a></excerpt></p><h2 id=""><a href="#" class="headerlink" title=""></a><the rest="" of="" contents="" |="" 余下全文=""></the></h2><h2 id="内网穿透的需求"><a href="#内网穿透的需求" class="headerlink" title="内网穿透的需求"></a>内网穿透的需求</h2><p>最近一直想实现校园内网之间的资源共享和分享校园生活，数据共享采用p2p的方式，这样可以减小服务器的压力，而且下载速度是随着下载人数的增加而上升的。如果通过FTP，C/S架构的方式会随着下载量的增加而减小，因为服务器的总出口带宽是一定的，所以很容易理解。这样就解决了数据共享。</p><p>对于分享校园生活，最好的方式就是建立论坛，每个人可以通过发帖来进行交流。所以CAUC-OB就这样诞生了。该服务器搭建与内网中，所以内网访问可以免流同时速度还更快。但是搭建与内网的缺点就是外网无法访问，很容易理解，该服务器的地址为10.5.42.11很明显为A类IP地址的内网IP段所以外网肯定无法访问。所以此时就有实现内网穿透的需求。</p><h2 id="ngrok实现内网穿透"><a href="#ngrok实现内网穿透" class="headerlink" title="ngrok实现内网穿透"></a>ngrok实现内网穿透</h2><p>对于内网穿透有很多其它的方式，这里就不一一介绍，其它的方式有收费的，有限定免费的，对于我当然想用完全自主的方式来实现，所以这里选择了ngrok开源项目来实现内网穿透。ngrok需要内网客户端连接外网服务端来实现内网穿透。</p><h3 id="ngrok个平台系统版本"><a href="#ngrok个平台系统版本" class="headerlink" title="ngrok个平台系统版本"></a>ngrok个平台系统版本</h3><p>我这里使用的win10自带的ubuntu来实现对于客户端和服务端的编译的，对于Linux环境，可以通过安装双系统（这种方式我不是很推荐，因为两个系统如果想实现数据交换linux需要支持NTFS文件系统，在众多的文件系统中linux偏偏对NTFS的支持不是很好（毕竟NTFS是一个闭源的商业系统）），或是安装虚拟机，在虚拟机中运行Linux系统即可。</p><p>我的Linux环境如下：</p><p>​    系统：Ubuntu18.04</p><p><img src="/2018/10/23/ngrokser/ubuntu.jpg" alt=""></p><p>外网服务器版本：</p><p>​    系统：CentOS7</p><p><img src="/2018/10/23/ngrokser/ngrokser.jpg" alt=""></p><p>内网服务器版本：</p><p>​    硬件平台：树莓派3</p><p>​    系统：Raspberry</p><p><img src="/2018/10/23/ngrokser/ngrokcli.jpg" alt=""></p><h3 id="编译ngrok服务端与客户端"><a href="#编译ngrok服务端与客户端" class="headerlink" title="编译ngrok服务端与客户端"></a>编译ngrok服务端与客户端</h3><p>克隆ngrok源码：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/inconshreveable/ngrok.git <span class="comment">#将ngrok源代码克隆回本地</span></span><br></pre></td></tr></table></figure><p>克隆好的目录结构如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zhangshuo@DESKTOP-2AKT8V3:~/ngrok2$ pwd #显示当前目录路径</span><br><span class="line">/home/zhangshuo/ngrok2</span><br><span class="line">zhangshuo@DESKTOP-2AKT8V3:~/ngrok2$ ls #克隆好的目录结构</span><br><span class="line">CONTRIBUTORS  Makefile   assets  contrib    src</span><br><span class="line">LICENSE       README.md  bin     docs</span><br></pre></td></tr></table></figure><p>安装go语言环境：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update #更新库</span><br><span class="line">sudo apt-get install golang #安装go语言</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GOPATH=/usr/local/ngrok/  #设置环境变量，Go语言的安装位置</span><br><span class="line">export NGROK_DOMAIN="ngrok.yourdomain.com"  #设置环境变量，ngrok域名</span><br></pre></td></tr></table></figure><p>为域名生成证书：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj "/CN=$NGROK_DOMAIN" -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line">openssl req -new -key server.key -subj "/CN=$NGROK_DOMAIN" -out server.csr</span><br><span class="line">openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000</span><br></pre></td></tr></table></figure><p>生成的证书如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zhangshuo@DESKTOP-2AKT8V3:~/ngrok2$ ls</span><br><span class="line">CONTRIBUTORS  Makefile   assets  contrib  rootCA.key  rootCA.srl  server.csr  src</span><br><span class="line">LICENSE       README.md  bin     docs     rootCA.pem  server.crt  server.key</span><br></pre></td></tr></table></figure><p>拷贝证书到指定位置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt  #复制rootCA.pem到assets/client/tls/并更名为ngrokroot.crt</span><br><span class="line">cp server.crt assets/server/tls/snakeoil.crt #复制server.crt到assets/server/tls/并更名为snakeoil.crt</span><br><span class="line">cp server.key assets/server/tls/snakeoil.key #复制server.key到assets/server/tls/并更名为snakeoil.key</span><br></pre></td></tr></table></figure><p>进行编译：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#linux服务端</span><br><span class="line">GOOS=linux GOARCH=386 make release-server</span><br><span class="line">#linux客户端</span><br><span class="line">GOOS=linux GOARCH=386 make release-client</span><br><span class="line">#树莓派客户端</span><br><span class="line">GOOS=linux GOARCH=ram make release-client</span><br></pre></td></tr></table></figure><p>生成完成后，在工作目录的bin文件夹下，产生对应的文件。以编译linux平台为例，会产生“ngrok”与“ngrokd”这两个文件，前者客户端，后者需要运行在公网服务器上。</p><p>如下结构所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zhangshuo@DESKTOP-2AKT8V3:~/ngrok2$ tree bin/</span><br><span class="line">bin/</span><br><span class="line">├── go-bindata</span><br><span class="line">├── linux_386</span><br><span class="line">│   ├── ngrok</span><br><span class="line">│   └── ngrokd</span><br><span class="line">└── linux_arm</span><br><span class="line">    └── ngrok</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure><p>此时定制的客户端和服务端以准备就绪。</p><h2 id="添加域名解析"><a href="#添加域名解析" class="headerlink" title="添加域名解析"></a>添加域名解析</h2><p>在自己的域名解析中将*.ngrok与ngrok都指向您的主机IP，我的域名为腾讯云负责解析的：</p><p><img src="/2018/10/23/ngrokser/jiexi.jpg" alt=""></p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>将bin/linux_386/ngrokd，snakeoil.key，snakeoil.crt三个文件上传至服务器，在服务器端运行ngrok服务程序。</p><p>我这里使用xshell连接centos进行配置，服务器中的文件格式为：</p><p><img src="/2018/10/23/ngrokser/centos.jpg" alt=""></p><p>因为使用的是xshell登陆的服务器，所以如果在终端中启动服务的话当终端关闭之后进程也会结束所以要使用screen命令进行程序的后台运行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zhangshuo @ VM_0_7_centos <span class="keyword">in</span> ~/ngrok [10:56:23] <span class="comment">#使用screen命令打开一个屏幕</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> screen</span></span><br></pre></td></tr></table></figure><p>然后启动服务端程序：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> zhangshuo @ VM_0_7_centos <span class="keyword">in</span> ~/ngrok [10:57:01] C:1 <span class="comment">#注意该目录下必须包含ngrokd运行程序，且该程序要给执行权限，和snakeoil.key，snakeoil.crt这两个文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./ngrokd -tlsKey=<span class="string">"snakeoil.key"</span> -tlsCrt=<span class="string">"snakeoil.crt"</span> -domain=<span class="string">"ngrok.zhangshuocauc.cn"</span> -httpAddr=<span class="string">":801"</span> -httpsAddr=<span class="string">":802"</span> &amp;</span></span><br></pre></td></tr></table></figure><p>启动服务后将screen送入后台运行即可：</p><p>将该screen送入后台的命令为：Ctrl+a,d。此时服务端配置完毕</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>同样的将bin/linux_arm/ngrok文件拷贝到树莓派客户端中家目录下。</p><p>在家目录下建立ngrok配置文件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch ngrok.cfg #建立ngrok的配置文件</span><br><span class="line">vim ngrok.cfg #使用vim编辑器进行编辑</span><br><span class="line">在该文件中写入如下配置</span><br><span class="line">server_addr: "ngrok.你的域名.com:4443"</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure><p>在树莓派客户端中加入开机启动程序即在/etc/rc.local文件中加入客户端启动的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/rc.local #使用管理员权限编辑rc.loal文件，并在exit0前面加入</span><br><span class="line">/home/pi/ngrok -subdomain kyt -config=/home/pi/ngrok.cfg 80 &amp;&gt;/dev/null &amp;</span><br><span class="line"></span><br><span class="line">上面的命令即为启动ngrok客户端的配置命令，上面的命令采用绝对路径的方式</span><br></pre></td></tr></table></figure><p>此时配置完毕将树莓派端重启即可通过访问：<a href="http://kyt.ngrok.zhangshuocauc.cn:801/" target="_blank" rel="noopener">http://kyt.ngrok.zhangshuocauc.cn:801/</a></p><p>来实现外网访问内网的web服务。</p><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; ngrok内网穿透：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;通过ngrok实现外网I访问内网web服务器&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="ngrok" scheme="https://zhangdashuo.github.io/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>关于不蒜子域名更改</title>
    <link href="https://zhangdashuo.github.io/2018/10/23/busuanzi/"/>
    <id>https://zhangdashuo.github.io/2018/10/23/busuanzi/</id>
    <published>2018-10-23T09:00:27.000Z</published>
    <updated>2018-10-23T09:28:17.402Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 关于不蒜子域名更改：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>不蒜子只是以前的域名过期了，并不是不能用了！！！！！<br><a id="more"></a></excerpt></p><h2 id=""><a href="#" class="headerlink" title=""></a><the rest="" of="" contents="" |="" 余下全文=""></the></h2><p>登陆博客时发现底部的统计数据没有了，当时以为只是不蒜子系统暂时出错，就没有在意，但是过了几天通过多个终端登陆发现博客的统计数据还是没有，此时应该查找原因了。这段时间并没有对博客的源码进行过更改，所以我就怀疑是不蒜子自己的问题，所以登陆不蒜子官网发现果然是，看到原因莫名的同情和无奈。</p><p><img src="/2018/10/23/busuanzi/tongzhi.jpg" alt=""></p><p>所以只需要将不蒜子的引用域名进行替换即可。</p><p>这里以hexo博客系统为例：</p><p>进入hexo博客系统的跟目录查找dn-lbstatics.qbox.me代码段：</p><p><code>grep dn-lbstatics.qbox.me  ./ -r</code></p><p>查找之后将域名更换即可</p><p>我是用的主题为spfk，经过查找需要更改的文件为：</p><p><code>/home/zhangshuo/hexo/themes/spfk/layout/_partial/after-footer.ejs</code></p><p>更改以后的文件为：</p><p><img src="/2018/10/23/busuanzi/daima.jpg" alt=""></p><p>此时不蒜子可以正常工作：</p><p><img src="/2018/10/23/busuanzi/tongji.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 关于不蒜子域名更改：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;不蒜子只是以前的域名过期了，并不是不能用了！！！！！&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="hexo" scheme="https://zhangdashuo.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第9集</title>
    <link href="https://zhangdashuo.github.io/2018/08/11/redhat09/"/>
    <id>https://zhangdashuo.github.io/2018/08/11/redhat09/</id>
    <published>2018-08-11T04:06:53.000Z</published>
    <updated>2018-08-11T04:09:26.521Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第9集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>btrfs文件系统、压缩工具及for语句、程序包管理<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="btrfs文件系统管理与应用"><a href="#btrfs文件系统管理与应用" class="headerlink" title="btrfs文件系统管理与应用"></a>btrfs文件系统管理与应用</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第9集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;btrfs文件系统、压缩工具及for语句、程序包管理&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>脚本处理Typora中的tab字符</title>
    <link href="https://zhangdashuo.github.io/2018/08/07/typora2md/"/>
    <id>https://zhangdashuo.github.io/2018/08/07/typora2md/</id>
    <published>2018-08-07T14:27:54.000Z</published>
    <updated>2018-08-07T15:45:32.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 脚本处理Typora中的tab字符：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>用脚本自动处理Typora中的tab字符为makedown标准的tab制表符<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h3 id="Typora编辑器简介"><a href="#Typora编辑器简介" class="headerlink" title="Typora编辑器简介"></a>Typora编辑器简介</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown。完全采用Markdown编辑器的博客平台有Ghost和Typecho。</p><p>所以对于我的博客系统也是基于Markdown，对于编写Markdown格式的话可以使用Makedown语言进行命令方式的格式编写，但对于非编辑专业需要的来说这样反而效率并不高，因为我们对于博客的书写来说应用该语言很少，所以最好的方式就是使用Makedown编辑器，这里介绍一款非常简洁而且所见即所得编辑器那就是Typora。</p><p>Typora官网的界面</p><p><img src="/2018/08/07/typora2md/guanwang.png" alt=""></p><p>可以看到Typora的官网是多么的简介，同时也再次体现了他的所见即所得的中心。</p><p>对于Typora如果要定义一个标题可以输入## 这是一个标题如图：</p><p><img src="/2018/08/07/typora2md/biaoti.jpg" alt=""></p><p>然后按回车此时可以看到马上就会有一个标题呈现在眼前：</p><p><img src="/2018/08/07/typora2md/biaoti1.jpg" alt=""></p><p>这就是非常简洁的Typora。</p><h3 id="Typora中诡异的tab符"><a href="#Typora中诡异的tab符" class="headerlink" title="Typora中诡异的tab符"></a>Typora中诡异的tab符</h3><p>如图这是在Typora中所使用制表符显示的缩进效果：</p><p><img src="/2018/08/07/typora2md/tab.jpg" alt=""></p><p>但是在vim下打开就会看到如下的诡异的制表符：</p><p><img src="/2018/08/07/typora2md/vimtab.jpg" alt=""></p><p>但是对于makedown中标准的缩进方式应该是使用<code>&amp;emsp;&amp;emsp;</code>这两个符号表示缩进两个字符</p><h3 id="脚本处理Typora中的tab符"><a href="#脚本处理Typora中的tab符" class="headerlink" title="脚本处理Typora中的tab符"></a>脚本处理Typora中的tab符</h3><p>我用Typora的目的是为了博客的编写，所以我希望的是用Typora编辑完的makedown直接替换博客源文件中的文章即可，但是由于tab制表符的不匹配到网页下所有的缩进都没有了，因为makedown不识别Typora格式的制表符，所以以前的做法是用vim编辑器一行一行的改，通常如果一篇博客要写两个小时的话，改格式还需要最少半个小时，这还需要手速非常快的情况下（使用vim的各种快捷键，不使用鼠标），所以对于这个我就很是苦恼所以打算写一个脚本来自动处理。</p><p>其实对于前面的文章一直都是手动改的格式，之所以这样是因为如果要进行文档的编辑，就需要使用sed命令再配合regex表达式（正则表达式），来进行模式的匹配和文本的处理。而我对于grep和sed这两个命令很是心虚，不敢轻易使用（我只想，grep虐我千百遍，我待grep如初恋）。但是这样手动实在是太麻烦所以还是决定写一个脚本。脚本内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Version:0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zhangshuo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Description:处理Typora编辑的MakeDown中的tab符，将tab替换为makedown的制表符&amp;emsp;&amp;emsp;</span></span><br><span class="line"></span><br><span class="line">[ $# -lt 1 ] &amp;&amp; echo "Are you a pig?Can't you give a file?" &amp;&amp; exit 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed -i 's@\xe2\x80\x8b@@g' $1 #清除文本中&lt;200b&gt;</span><br><span class="line">sed -i "s/\t/\&amp;emsp;\&amp;emsp;/g" $1 #将所有的制表符用&amp;emsp;&amp;emsp;进行替换</span><br></pre></td></tr></table></figure><p>用法：</p><p>该脚本需要传递一个参数，参数即为你要处理的文档，注意该操作会在文档中直接修改，如果需要请先备份再使用该脚本进行处理。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ ./blogrmtab.sh #如果不跟要处理的文章则会报错</span><br><span class="line">Are you a pig?Can't you give a file?</span><br><span class="line">[zhangshuo@localhost ~]$ ./blogrmtab.sh test.md #命令的使用方法</span><br></pre></td></tr></table></figure><p>此时处理完毕，可以看到处理的效果如下：</p><p><img src="/2018/08/07/typora2md/vimtab2.jpg" alt=""></p><p>此时在网页中即可显示正常的制表效果。</p><p>-EOF</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 脚本处理Typora中的tab字符：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;用脚本自动处理Typora中的tab字符为makedown标准的tab制表符&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://zhangdashuo.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="myscript" scheme="https://zhangdashuo.github.io/tags/myscript/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第8集</title>
    <link href="https://zhangdashuo.github.io/2018/08/03/redhat08/"/>
    <id>https://zhangdashuo.github.io/2018/08/03/redhat08/</id>
    <published>2018-08-03T02:09:42.000Z</published>
    <updated>2018-08-11T04:05:12.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第8集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>文件系统挂载、ext文件系统及read命令、Linux RAID、lvm应用<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="文件系统挂载与管理工具"><a href="#文件系统挂载与管理工具" class="headerlink" title="文件系统挂载与管理工具"></a>文件系统挂载与管理工具</h2><p>挂载：将额外文件系统与根文件系统下某存在的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为称之为挂载</p><p>卸载：解除此关联关系的过程称之为卸载</p><p>把设备关联挂载点：Mount Point</p><p>&emsp;&emsp;命令：mount</p><p>卸载时：可使用设备，也可以使用挂载点</p><p>&emsp;&emsp;命令：umount</p><p>注意：挂载点下原有文件在挂载完成后会被临时隐藏</p><p>挂载方法：mount DEVICE MOUNT_POINT</p><p>&emsp;&emsp;mount：通过查看/etc/mtab文件来显示当前系统已挂载的所有设备</p><p>&emsp;&emsp;mount [-fnrsvw][-t vfstype][-o options] device dir</p><p>&emsp;&emsp;&emsp;&emsp;device：指明要挂载的设备</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、设备文件：例如/dev/sda5</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、卷标：-L ‘LABEL’ </p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（3）、UUID：-U ‘UUID’</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（4）、伪文件系统名称：proc，sysfs，devtmpfs，configfs等</p><p>&emsp;&emsp;&emsp;&emsp;dir：挂载点</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;要事先存在，建议使用空目录。注意：进程正在使用的设备无法被卸载</p><p>&emsp;&emsp;&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-t vsftype：指明要挂载的设备上的文件系统类型</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-r：readonly，以只读形式挂载</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-w：read and write 读写形式挂载</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a：自动挂载所有支持自动挂载的设备（定义在了/etc/fstab）文件中，自动挂载选项中有“自动挂载”功能的文件系统。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-n：挂载后不更新/etc/mtab文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L ‘LABEL’：以卷标指定挂载设备</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-U ‘UUID’：以UUID指定要挂载的设备</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-B：绑定目录到另一个目录（有人说这个功能的作用是来弥补硬链接无法链接目录的缺点）</p><p>&emsp;&emsp;&emsp;&emsp;查看内核追踪到的已挂载的所有设备：cat /proc/mounts</p><p>&emsp;&emsp;&emsp;&emsp;-o options：挂载文件系统的选项</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;async：异步模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;sync：同步模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;atime/noatime：包括目录和文件是否更新访问时间</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;diratime/nodiratime：目录的访问时间戳</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;auto/noauto：是否支持自动挂载</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;exec/noexec：是否支持将文件系统上的应用程序运行为进程</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dev/nodev：是否支持在此文件系统上使用设备文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;suid/nosuid：是否支持suid</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;remount：重新挂载&emsp;&emsp;&emsp;&emsp;mount -o remount,ro /dev/sda3</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ro：只读形式挂载</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;rw：读写挂载</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;usr/nouser：是否允许普通用户挂载此设备</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acl：启用文件系统上的acl功能</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：上述选项可多个同时使用，彼此使用逗号分隔</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;默认挂载选项：defaults</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Use default options: rw, suid, dev, exec, auto, nouser, and async.</p><p>&emsp;&emsp;卸载命令：</p><p>&emsp;&emsp;&emsp;&emsp;# umount DEVICE</p><p>&emsp;&emsp;&emsp;&emsp;# umount MOUNT_POINT</p><p>&emsp;&emsp;&emsp;&emsp;查看正在访问指定文件系统的进程</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;fuser -v MOUNT_POINT</p><p>&emsp;&emsp;&emsp;&emsp;终止所有正在访问指定的文件系统的进程</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;fuser -km MOUNT_POINT</p><p>&emsp;&emsp;挂载交换分区：</p><p>&emsp;&emsp;&emsp;&emsp;启用：swapon</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;swapon [OPTION]…[DEVICE]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a：将/etc/fstab文件中所有设置为swap的设备，启动为交换区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-p：&lt;优先顺序&gt;：指定交换区的优先顺序；即指定优先使用那个交换分区</p><p>&emsp;&emsp;&emsp;&emsp;禁用：swapoff</p><p>&emsp;&emsp;查看内存空间的使用状态：</p><p>&emsp;&emsp;&emsp;&emsp;free [OPTION]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-m：以MB为单位</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-g：以GB为单位</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-h：以符合人类习惯的方式显示</p><p>&emsp;&emsp;文件系统空间占用等信息的查看工具：</p><p>&emsp;&emsp;&emsp;&emsp;df</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-h：human readable</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-i：inodes instead of blocks</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-P：以posix兼容的格式输出</p><p>&emsp;&emsp;查看某目录总体空间的占用状态：</p><p>&emsp;&emsp;&emsp;&emsp;du</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-h：human readable</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-s：summary</p><h2 id="ext文件系统原理基础及read命令"><a href="#ext文件系统原理基础及read命令" class="headerlink" title="ext文件系统原理基础及read命令"></a>ext文件系统原理基础及read命令</h2><p>文件挂载的配置文件：/etc/fstab</p><p>&emsp;&emsp;每行定义一个要挂载的文件系统，其内容格式如下：</p><p>&emsp;&emsp;要挂在的设备或文件系统&emsp;&emsp;挂载点&emsp;&emsp;文件系统类型&emsp;&emsp;挂载选项&emsp;&emsp;转储频率&emsp;&emsp;自检次序</p><p>&emsp;&emsp;要挂在的设备或伪文件系统：</p><p>&emsp;&emsp;&emsp;&emsp;设备文件、LABEL（LABEL=’ ‘）、UUID（UUID=’ ‘）、伪文件系统名称（proc，sysfs）</p><p>&emsp;&emsp;挂载点：</p><p>&emsp;&emsp;&emsp;&emsp;即为你要挂载的位置</p><p>&emsp;&emsp;文件系统类型：</p><p>&emsp;&emsp;&emsp;&emsp;指明该挂载文件系统的类型，文件类型必须准确</p><p>&emsp;&emsp;挂载选项：</p><p>&emsp;&emsp;&emsp;&emsp;一般就以默认选项进行挂载即可：即defaults</p><p>&emsp;&emsp;转储频率：</p><p>&emsp;&emsp;&emsp;&emsp;0：不做备份</p><p>&emsp;&emsp;&emsp;&emsp;1：每天转储</p><p>&emsp;&emsp;&emsp;&emsp;2：每隔一天转储</p><p>&emsp;&emsp;&emsp;&emsp;该选项基本都为不做备份，因为对于数据的备份会有很多其它好用的工具</p><p>&emsp;&emsp;自检次序：</p><p>&emsp;&emsp;&emsp;&emsp;0：不自检</p><p>&emsp;&emsp;&emsp;&emsp;1：首先自检，一般只有rootfs才会使用1</p><p>&emsp;&emsp;&emsp;&emsp;2…9：都可以使用</p><p>文件系统上的其它概念：</p><p>&emsp;&emsp;Inode：Index Node索引节点</p><p>&emsp;&emsp;链接文件：</p><p>&emsp;&emsp;&emsp;&emsp;硬链接：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不能对目录进行，防止循环引用、</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;不能跨分区进行，这个很好理解</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;指向同一个inode的多个不同的路径，创建文件的硬链接即为为inode创建新的引用路径，因此会增加其引用计数。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;创建硬链接的方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ln SRC DEST</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-v：verbose</p><p>&emsp;&emsp;&emsp;&emsp;符号链接：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;可以对目录进行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;还可以跨分区，就类似windows的快捷方式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;指向的是另一个文件的路径，其大小为指向的路径，字符串的长度，不增加或减少目标文件inode的引用计数。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;创建软连接的方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ln -s SRC DEST</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-v：verbose</p><p>练习：写一个脚本，完成如下功能</p><p>&emsp;&emsp;（1）、列出当前系统识别到的所有磁盘设备</p><p>&emsp;&emsp;（2）、如果磁盘数量为1，则显示其空间使用信息，否则，显示最后一个磁盘上的空间使用信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by zhangshuo 2018/08/10</span></span><br><span class="line">[ ! $UID -eq 0 ] &amp;&amp; echo "not root" &amp;&amp; exit 2</span><br><span class="line"></span><br><span class="line">DiskNumber=$(fdisk -l | grep -o "^Disk /dev/[sh]d[a-z]" | cut -d " " -f 2 | wc -l)</span><br><span class="line"></span><br><span class="line">echo "your disk number is $DiskNumber"</span><br><span class="line"></span><br><span class="line">if [ $DiskNumber -eq 1 ];then</span><br><span class="line">fistdisk=$(fdisk -l | grep -o "^Disk /dev/[sh]d[a-z]" | cut -d " " -f 2)</span><br><span class="line">echo "you only have one disk is $fistdisk"</span><br><span class="line">echo "the disk used is ..."</span><br><span class="line">df -h $fistdisk</span><br><span class="line">else</span><br><span class="line">lastdisk=$(fdisk -l | grep -o "^Disk /dev/[sh]d[a-z]" | cut -d " " -f 2 | tail -1) </span><br><span class="line">echo "the last disk is $lastdisk"</span><br><span class="line">echo "the disk used is ..."</span><br><span class="line">df -h $lastdisk</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里在付一个创建脚本的脚本，这样很多重复的内容就可以不用每次书写了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by zhangshuo 2018/08/10</span></span><br><span class="line"></span><br><span class="line">[ $# -eq 0 ] &amp;&amp; echo "no scripts name" &amp;&amp; exit 2</span><br><span class="line"></span><br><span class="line">echo "#!/bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">Version:0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Author:zhangshuo</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Date:$(date +%F)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">Description:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">BUG REPORTS:2292650292@qq.com<span class="string">" &gt;&gt; <span class="variable">$1</span></span></span></span><br><span class="line"></span><br><span class="line">chmod +x $1</span><br></pre></td></tr></table></figure><p>bash脚本编程之用户交互</p><p>&emsp;&emsp;read [OPTIONS] …[name]</p><p>&emsp;&emsp;&emsp;&emsp;-p “PROMPT” ：给定提示信息</p><p>&emsp;&emsp;&emsp;&emsp;-t “TIMEOUT” ：给定超时时间</p><p>bash程序调试运行用法</p><p>&emsp;&emsp;检测脚本中是否有语法错误：</p><p>&emsp;&emsp;&emsp;&emsp;bash -n /path/to/some_script</p><p>&emsp;&emsp;调试执行，输出每一步执行的详细信息：</p><p>&emsp;&emsp;&emsp;&emsp;bash -x /path/to/some_script</p><p>练习：</p><p>&emsp;&emsp;接受用户给定的一个磁盘，然后输出磁盘的分区信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by zhangshuo 2018/08/10</span></span><br><span class="line"></span><br><span class="line">[ ! $UID -eq 0 ] &amp;&amp; echo "not root" &amp;&amp; exit 2</span><br><span class="line"></span><br><span class="line">DiskNumber=$(fdisk -l | grep -o "^Disk /dev/[sh]d[a-z]" | cut -d " " -f 2 | wc -l)</span><br><span class="line"></span><br><span class="line">echo "your disk number is $DiskNumber"</span><br><span class="line">echo "your all disk is :"</span><br><span class="line">fdisk -l | grep -o "^Disk /dev/[sh]d[a-z]" | cut -d " " -f 2</span><br><span class="line"></span><br><span class="line">read -p "enter a disk:" diskname</span><br><span class="line"></span><br><span class="line">[ -z "$diskname" ] &amp;&amp; echo "no disk name" &amp;&amp; exit 2</span><br><span class="line"></span><br><span class="line">if fdisk -l | grep "^Disk $diskname" &amp;&gt; /dev/null;then</span><br><span class="line">echo "the $diskname mesages is :"</span><br><span class="line">fdisk -l $diskname</span><br><span class="line">else</span><br><span class="line">echo "no such disk"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="Linux-RAID"><a href="#Linux-RAID" class="headerlink" title="Linux RAID"></a>Linux RAID</h2><p>RAID：Redundant Arrays of Independent Disks 独立冗余磁盘阵列</p><p>&emsp;&emsp;优点：磁盘并行读写，有的硬件RAID设备自带内存和CPU，提高IO能力，提高耐用性，和数据的安全性，该方式是通过磁盘冗余来实现的。</p><p>&emsp;&emsp;级别：级别不同意味这多块磁盘组织在一起的工作方式有所不同</p><p>&emsp;&emsp;RAID实现的方式：</p><p>&emsp;&emsp;&emsp;&emsp;外接式磁盘阵列：通过扩展卡提供适配能力</p><p>&emsp;&emsp;&emsp;&emsp;内接式RAID：主板集成RAID控制器</p><p>&emsp;&emsp;&emsp;&emsp;软件模拟RAID：该方式会额外浪费CPU的资源，而且该种方式数据丢失时不易恢复</p><p>&emsp;&emsp;常用RAID级别：</p><p>&emsp;&emsp;&emsp;&emsp;RAID0：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;条带化方式，即将数据按chunk大小进行切割之后，按规则分别存储在两个硬盘之上</p><p>&emsp;&emsp;&emsp;&emsp;RAID1：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;镜像的方式，即将数据在两个硬盘上各存一份，来实现数据的冗余</p><p>&emsp;&emsp;&emsp;&emsp;RAID4：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在条带的基础上，增加一块校验盘来存放其它条带的异或校验码</p><p>&emsp;&emsp;&emsp;&emsp;RAID5：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在RAID4的基础上，校验盘不是固定的某个盘而是所有盘轮流做校验盘，这样可以均衡负载</p><p>&emsp;&emsp;&emsp;&emsp;RAID6：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在RAID5的基础上，增加一块校验盘，来保证数据的可靠性</p><p>&emsp;&emsp;&emsp;&emsp;RAID10：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;结合RAID0和RAID1，先做镜像之后再做条带，这种方式比较常用</p><p>&emsp;&emsp;&emsp;&emsp;RAID01</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;结合RAID0和RAID1，先做条带之后在做镜像。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">读写性能</th><th style="text-align:center">可用空间</th><th style="text-align:center">容错能力</th><th style="text-align:center">最少磁盘</th></tr></thead><tbody><tr><td style="text-align:center">RAID0</td><td style="text-align:center">提升</td><td style="text-align:center">N*min(s1,s2…)</td><td style="text-align:center">无</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">RAID1</td><td style="text-align:center">读提升写下降</td><td style="text-align:center">1*min(s1,s2…)</td><td style="text-align:center">有</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">RAID4</td><td style="text-align:center">提升</td><td style="text-align:center">(N-1)*min(s1,s2…)</td><td style="text-align:center">有</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">RAID5</td><td style="text-align:center">提升</td><td style="text-align:center">(N-1)*min(s1,s2…)</td><td style="text-align:center">有</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">RAID6</td><td style="text-align:center">提升</td><td style="text-align:center">(N-2)*min(s1,s2…)</td><td style="text-align:center">有</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">RAID10</td><td style="text-align:center">提升</td><td style="text-align:center">N*min(s1,s2…)/2</td><td style="text-align:center">有</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">RAID01</td><td style="text-align:center">提升</td><td style="text-align:center">N*min(s1,s2…)/2</td><td style="text-align:center">有</td><td style="text-align:center">4</td></tr></tbody></table><p>&emsp;&emsp;JBOD：Just a Bonch of Disks</p><p>&emsp;&emsp;&emsp;&emsp;功能：将多块磁盘空间合并为一个大的连续空间使用</p><p>&emsp;&emsp;&emsp;&emsp;可用空间：sum（s1,s2…）</p><p>&emsp;&emsp;Centos上的软件RAID的实现</p><p>&emsp;&emsp;&emsp;&emsp;结合内核中的md模块（multi devices）</p><p>&emsp;&emsp;&emsp;&emsp;mdadm：将任何块设备做成RAID</p><p>&emsp;&emsp;&emsp;&emsp;模式化的命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;创建模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-C</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;专用选项</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-l：级别</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-n：设备个数</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a （yes no）：自动为其创建设备文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-c：chunk大小即数据块大小 默认为64k</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-x: 指定空闲盘个数</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;管理模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–add,–remove,-fail</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm /dev/md# –fail /dev/sdb7 模拟将/dev/sdb7进行损坏</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm /dev/md1 -f /dev/sdb7  模拟硬盘损毁</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm /dev/md1 -r /dev/sdb7&emsp;&emsp; 卸载坏的硬盘</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm /dev/md1 -a /dev/sdb7&emsp;&emsp; 增加一块好的硬盘到raid</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;监控模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-F</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;增长模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-G</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;装配模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-A</p><p>&emsp;&emsp;创建2G的RAID0</p><p>&emsp;&emsp;&emsp;&emsp;可以使用4个512MB的磁盘。也可以使用2个1G的磁盘</p><p>&emsp;&emsp;&emsp;&emsp;创建RAID0 &emsp;&emsp;mdadm -C /dev/md0 -a yes -l 0 -n 2 /dev/sdb{5,6}</p><p>&emsp;&emsp;查看当前设备上的所有RAID&emsp;&emsp;cat /proc/mdstat </p><p>&emsp;&emsp;创建2G的RAID1</p><p>&emsp;&emsp;&emsp;&emsp;因为RAID1为镜像，最少使用两个磁盘，所以这里使用2个2G的磁盘来制作</p><p>&emsp;&emsp;&emsp;&emsp;创建RAID1 &emsp;&emsp;mdadm -C /dev/md0 -a yes -l 1 -n 2 /dev/sdb{5,6}</p><p>&emsp;&emsp;查看磁盘阵列的详细信息</p><p>&emsp;&emsp;&emsp;&emsp;mdadm -D /dev/md1 </p><p>&emsp;&emsp;停用阵列：</p><p>&emsp;&emsp;&emsp;&emsp;mdadm -S /dev/md#</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–stop </p><p>&emsp;&emsp;启动阵列</p><p>&emsp;&emsp;&emsp;&emsp;mdadm -A /dev/md#</p><p>&emsp;&emsp;完整删除RAID信息</p><p>&emsp;&emsp;&emsp;&emsp;1、查看RAID磁盘阵列信息，确认一下要关闭哪个。如：关闭md0这个阵列</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;cat /proc/mdstat</p><p>&emsp;&emsp;&emsp;&emsp;2、卸载md0这个阵列的挂载点</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;umount /mnt/RAID5</p><p>&emsp;&emsp;&emsp;&emsp;3、停止md0这个阵列，并释放与该阵列相关的所有资</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm -S /dev/md0</p><p>&emsp;&emsp;&emsp;&emsp;4、清除成员磁盘当中阵列的超级块信息，这一步很重要！</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mdadm –zero-superblock /dev/sdb[1-3,5]</p><p>&emsp;&emsp;&emsp;&emsp;5、删除或注释/etc/fstab上的挂载信息</p><p>&emsp;&emsp;&emsp;&emsp;6、删除或注释/etc/mdadm.conf对应的RAID信息<br>&emsp;&emsp;</p><p>&emsp;&emsp;watch：周期性的执行命令，并以全屏方式显示结果</p><p>&emsp;&emsp;&emsp;&emsp;-n #：指定周期长度，单位为秒，默认为2</p><p>&emsp;&emsp;&emsp;&emsp;watch -n # ‘COMMAND’ </p><p>&emsp;&emsp;将raid信息保存至文件以后便可开机装配</p><p>&emsp;&emsp;&emsp;&emsp;mdadm -D –scan &gt; /etc/mdadm.conf </p><p>&emsp;&emsp;mke2fs -E stride 16 :格式化时指定条带大小这样可以提高raid性能。chuck大小默认为64k 磁盘块大小为4k所以这里数字为16.注意用优盘做raid时它的chunk大小为512k。</p><p>&emsp;&emsp;lsmod:显示已经加载到内核中的模块状态信息</p><p>&emsp;&emsp;mdadm：用户空间工具只是管理工具，对于raid其实还是内核中raid模块进行的管理。</p><h2 id="LVM应用"><a href="#LVM应用" class="headerlink" title="LVM应用"></a>LVM应用</h2><p>&emsp;&emsp;LVM：Logical Volume Manager </p><p>&emsp;&emsp;dm：Device Mapper,将一个或多个底层块设备组织成一个逻辑设备的模块</p><p>&emsp;&emsp;在Centos中对于逻辑卷的设备表示方法有三种：</p><p>&emsp;&emsp;&emsp;&emsp;/dev/mapper/VG_name-LV_name</p><p>&emsp;&emsp;&emsp;&emsp;/dev/VG_name/LV_name</p><p>&emsp;&emsp;&emsp;&emsp;/dev/dm-#</p><p>&emsp;&emsp;&emsp;&emsp;但是所有的表示方法都最终指向了/dev/dm-#</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /dev/mapper/*</span><br><span class="line">lrwxrwxrwx. 1 root root       7 Aug 11 10:00 /dev/mapper/centos-home -&gt; ../dm-2</span><br><span class="line">lrwxrwxrwx. 1 root root       7 Aug 11 10:00 /dev/mapper/centos-root -&gt; ../dm-0</span><br><span class="line">lrwxrwxrwx. 1 root root       7 Aug 11 10:00 /dev/mapper/centos-swap -&gt; ../dm-1</span><br><span class="line">crw-------. 1 root root 10, 236 Aug 11 10:00 /dev/mapper/control</span><br><span class="line">[root@localhost ~]# ll /dev/centos/*</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 11 10:00 /dev/centos/home -&gt; ../dm-2</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 11 10:00 /dev/centos/root -&gt; ../dm-0</span><br><span class="line">lrwxrwxrwx. 1 root root 7 Aug 11 10:00 /dev/centos/swap -&gt; ../dm-1</span><br><span class="line">[root@localhost ~]# ll /dev/dm*</span><br><span class="line">brw-rw----. 1 root disk 253, 0 Aug 11 10:00 /dev/dm-0</span><br><span class="line">brw-rw----. 1 root disk 253, 1 Aug 11 10:00 /dev/dm-1</span><br><span class="line">brw-rw----. 1 root disk 253, 2 Aug 11 10:00 /dev/dm-2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：逻辑卷的快照必须和逻辑卷在同一个卷组中切必须留有足够的空间给快照卷</p><p>&emsp;&emsp;&emsp;&emsp;将物理卷加入到卷组中时会给物理卷分块类似chunk此时的块叫做pe：physical extend 物理盘区 既逻辑存储单位</p><p>&emsp;&emsp;&emsp;&emsp;将pe放到逻辑卷中，即逻辑卷的存储空间是由若干个pe组成的。此时的pe叫做le：logical extend 逻辑盘区</p><p>&emsp;&emsp;physical volume pv:物理卷</p><p>&emsp;&emsp;&emsp;&emsp;pvcreate,pvremove,pvscan,pvdisplay,pvmove</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例如：pvcreate /dev/sdb{11,12}</p><p>&emsp;&emsp;&emsp;&emsp;pvs :查看当前系统的pv</p><p>&emsp;&emsp;&emsp;&emsp;pvdisplay</p><p>&emsp;&emsp;volume group vg:卷组类似扩展分区</p><p>&emsp;&emsp;&emsp;&emsp;vgcreate,vgremove,vgextend,vgreduce,vgs,vgdisplay,vgscan</p><p>&emsp;&emsp;&emsp;&emsp;vgs：显示所有vg</p><p>&emsp;&emsp;&emsp;&emsp;vgcreate:创建卷组</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-s：可以指定pe大小默认为4m 该选项可以带单位用时man一下</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例如：vgcreate myvg /dev/sdb{11,12}</p><p>&emsp;&emsp;&emsp;&emsp;vgremove vg_name ：移除该vg</p><p>&emsp;&emsp;&emsp;&emsp;vgcreat VG_NAME&emsp;&emsp;/PATH/TO/PV</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-s #:PE大小，默认为4MB</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例如：vgcreate -s 8M myvg /dev/sdb{11,12} </p><p>&emsp;&emsp;缩小一个vg的过程</p><p>&emsp;&emsp;&emsp;&emsp;1、pvmove 移除一个pv该过程会自动复制数据</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;pvmove /dev/sdb12</p><p>&emsp;&emsp;&emsp;&emsp;2、vgreduce myvg /dev/sdb12</p><p>&emsp;&emsp;&emsp;&emsp;3、pvremove 真正移除pv</p><p>&emsp;&emsp;增加一个vg的过程</p><p>&emsp;&emsp;&emsp;&emsp;1、pvcreate /dev/sdb12</p><p>&emsp;&emsp;&emsp;&emsp;2、vgextend myvg /dev/sdb12</p><p>&emsp;&emsp;logical volume：逻辑卷</p><p>&emsp;&emsp;&emsp;&emsp;lvcreate,lvremove,lvextend,lvreduce,lvresize,lvs,lvdisplay</p><p>&emsp;&emsp;&emsp;&emsp;lvs：列出所有逻辑卷</p><p>&emsp;&emsp;&emsp;&emsp;lvcreate -n LV_NAME -L #G VG_NAME</p><p>&emsp;&emsp;&emsp;&emsp;lv创建好以后其设备目录为/dev/vgname/lvname，但是其实真正的lv设备是在/dev/mapper下面</p><p>&emsp;&emsp;删除一个lv</p><p>&emsp;&emsp;1、卸载 </p><p>&emsp;&emsp;&emsp;&emsp;umount /run/media/zhangshuo/vg0/</p><p>&emsp;&emsp;2、删除</p><p>&emsp;&emsp;&emsp;&emsp;lvremove /dev/myvg/testlv</p><p>&emsp;&emsp;练习：创建一个由两个物理卷组成的大小为20G的卷组myvg，要求其PE大小为16M，而后在此卷组中创建一个大小为5G的逻辑卷lv1，此逻辑卷要能在开机后自动挂载至/users目录，且支持ACL功能</p><p>&emsp;&emsp;扩展逻辑卷的过程：</p><p>&emsp;&emsp;&emsp;&emsp;lvextend ：扩展其物理边界</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L [+]# /PATH/TO/LV</p><p>&emsp;&emsp;&emsp;&emsp;resize2fs ：扩展其文件系统边界</p><p>&emsp;&emsp;&emsp;&emsp;resize2fs /PATH/TO/LV 5G 修复逻辑边界到5g</p><p>&emsp;&emsp;&emsp;&emsp;resize2fs -p /PATH/TO/LV 扩展至最大</p><p>&emsp;&emsp;缩减逻辑卷的过程：</p><p>&emsp;&emsp;&emsp;&emsp;注意：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1、不能在线缩减，要先卸载再缩减</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2、确保缩减后的空间大小依然能存储原有的所有数据</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3、在缩减之间应线强行检查文件，以确保文件系统处于一致性状态：</p><p>&emsp;&emsp;&emsp;&emsp;1、df -lh 确保大小足够</p><p>&emsp;&emsp;&emsp;&emsp;2、umount&emsp;&emsp;卸载挂载</p><p>&emsp;&emsp;&emsp;&emsp;3、e2fsck -f /PATH/TO/LV&emsp;&emsp;检查文件系统</p><p>&emsp;&emsp;&emsp;&emsp;4、resize2fs</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;resize2fs /PATH/TO/PV&emsp;&emsp;3G 缩小至3G</p><p>&emsp;&emsp;&emsp;&emsp;5、lvreduce -L [-]# /PATH/TO/LV</p><p>&emsp;&emsp;&emsp;&emsp;6、重新挂载</p><p>&emsp;&emsp;快照卷</p><p>&emsp;&emsp;&emsp;&emsp;注意：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1、生命周期为整个数据时常：在这段时常内，数据的增长量不能超出快照卷大小：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2、快照卷应该是只读的</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3、跟原卷在同一卷组内</p><p>&emsp;&emsp;lvcreate</p><p>&emsp;&emsp;&emsp;&emsp;-s :指定为快照卷</p><p>&emsp;&emsp;&emsp;&emsp;-p r|w 指定权限，一般快照用于数据备份使用所以快照卷不允许修改所以应该为只读</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;lvcreate -L # -n SLV_NAME -s -p r /PATH/TO/LV</p><h2 id="文件系统的挂载使用"><a href="#文件系统的挂载使用" class="headerlink" title="文件系统的挂载使用"></a>文件系统的挂载使用</h2><p>挂载光盘设备：</p><p>&emsp;&emsp;光盘设备文件：</p><p>&emsp;&emsp;&emsp;&emsp;IDE接口的：/dev/hdc</p><p>&emsp;&emsp;&emsp;&emsp;SATA接口的：/dev/sr0</p><p>&emsp;&emsp;&emsp;&emsp;符号链接文件：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/dev/cdrom</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/dev/cdrw</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/dev/dvd</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/dev/dvdrw</p><p>&emsp;&emsp;&emsp;&emsp;例如：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<code>mount -r /dev/cdrom /media/cdrom</code> ：以只读方式挂载光盘至/media/cdrom下</p><p>dd命令：convert and copy a file</p><p>&emsp;&emsp;用法：dd if=/PATH/FROM/SRC of=/PATH/TO/DEST</p><p>&emsp;&emsp;&emsp;&emsp;bs=# 复制的块大小，默认单位为字节</p><p>&emsp;&emsp;&emsp;&emsp;count=# 要复制多少个bs</p><p>&emsp;&emsp;比如：</p><p>&emsp;&emsp;&emsp;&emsp;完全复制一个磁盘到另一个磁盘时：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd if=/dev/sda of=/dev/sdb</p><p>&emsp;&emsp;&emsp;&emsp;备份磁盘的MBR信息：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd if=/dev/sda of=/tmp/mbr.bk bs=512 count=1</p><p>&emsp;&emsp;&emsp;&emsp;清除MBR分区表：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd if=/dev/zero of=/dev/sda bs=512 count=1</p><p>&emsp;&emsp;&emsp;&emsp;破坏MBR中的bootloader</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd if=/dev/zero of=/dev/sda bs=256 count=1</p><p>&emsp;&emsp;&emsp;&emsp;制作linux或是windows启动盘时：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd if=/PATH/TO/linux.iso of=/dev/sdb bs=4M</p><p>-EOF</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第8集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;文件系统挂载、ext文件系统及read命令、Linux RAID、lvm应用&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第7集</title>
    <link href="https://zhangdashuo.github.io/2018/08/03/redhat07/"/>
    <id>https://zhangdashuo.github.io/2018/08/03/redhat07/</id>
    <published>2018-08-03T02:09:36.000Z</published>
    <updated>2018-08-07T14:15:21.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第7集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>find命令、if语句、磁盘管理、文件系统管理<br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><p>&emsp;&emsp;在文件系统上查找符合条件的文件：</p><p>&emsp;&emsp;linux下的文件查找工具常用的有两个：locate和find</p><p>&emsp;&emsp;&emsp;&emsp;非实时查找（基于数据库进行的查找）：locate</p><p>&emsp;&emsp;&emsp;&emsp;实时查找：find</p><p>&emsp;&emsp;locate：</p><p>&emsp;&emsp;&emsp;&emsp;依赖于事先构建的索引，索引的构建是在系统较为空闲时自动进行的（基于周期性任务）。</p><p>&emsp;&emsp;&emsp;&emsp;如果要手动更新数据库可以使用命令：updatedb</p><p>&emsp;&emsp;&emsp;&emsp;索引构建过程需要遍历整个文件系统，所以该过程会很耗资源</p><p>&emsp;&emsp;&emsp;&emsp;工作特点：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找速度快：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;模糊查找：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;非实时查找：</p><p>&emsp;&emsp;&emsp;&emsp;用法：locate [OPTION]… PATTERN…</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;常用方法：locate KEYWORD</p><p>&emsp;&emsp;find：</p><p>&emsp;&emsp;&emsp;&emsp;实时查找工具，通过遍历指定路径下的文件系统完成文件查找</p><p>&emsp;&emsp;&emsp;&emsp;工作特点：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找速度比较慢</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;但是查找比较精确：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;基于实时查找：</p><p>&emsp;&emsp;&emsp;&emsp;用法：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find [OPTION] … [查找路径][查找条件] [处理动作]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找路径：指定具体目标路径，默认为当前目录</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找条件：指定的查找标准，可以以文件名，大小，类型，权限等标准进行，默认为找出路径下的所有文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;处理动作：对符合条件的文件做什么操作，默认为输出至屏幕</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找条件：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、根据文件名查找：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-name “文件名”  对于文件名支持使用glob</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例如：find /etc -name “passwd” ：在/etc目录下查找以passwd为文件名的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /etc -name “*passwd” ：在/etc目录下查找以passwd结尾的文件名的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /etc -name “passwd *”：在/etc目录下查找以passwd开头的文件名的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-iname “文件名”：不区分字母大小写</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-regex “PATTERN” ：以PATTERN匹配整个文件路径字符串，而不仅仅是文件名称</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、根据属主，属组查找</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-user USERNAME ：查找属主为指定用户的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /home -user zhangshuo -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /tmp -user root -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-group USERNAME ：查找属组为指定组的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /home -group zhangshuo -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-uid USERID：查找属主为指定的UID号的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-gid GROUPID：查找属组为指定的GID号的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-nouser：查找没有属主的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-nogroup：查找没有属组的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（3）、根据文件类型查找</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-type TYPE</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;TYPE：f,d,l,p,s,b,c等</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（4）、组合条件：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;与：-a</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;或：-o</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;非：-not，！</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find / -nouser -o -nogroup -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find / \( -nouser -o -nogroup \) -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：组合条件时后面的ls只会和组合条件测试后面的一起匹配如果要使用，则需要加括号</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find / \( -not -name “fstab” -a -not -user root \) -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find / -not \( -name “fstab” -o -user root \) -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（5）、根据文件大小来查找：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-size [+|-]#UNIT</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;常用单位：K,M,G</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#UNIT：表示的范围为(#-1,#]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-#UNIT：表示的范围为[0,#-1]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+#UNIT：表示的范围为(#,oo)</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（6）、根据时间戳来查找：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;以天为单位：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-atime：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-mtime：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-ctime：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[+|-]#</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#：表示的范围为[#,#+1)</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-#：表示的范围为[0,#)</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+#：表示的范围为[#+1,oo)</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;以分钟为单位：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-amin：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-mmin：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-cmin：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;用法同以天为单位的类似</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（7）、根据权限查找：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-perm [/|-]MODE </p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;MODE：精确权限匹配  find /etc -perm 600 -ls</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/MODE：任何一类（u，g，o）对象的权限中只要能有一位匹配即可</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /etc -perm /222 -ls ：查找/etc目录下任何用户都有写权限的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;find /etc -perm /600 -ls ：查找/etc目录下属主有度或写权限的文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-MODE：每一类对象都必须同时拥有为其指定的权限标准</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;处理动作：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-print：默认的处理动作，显示至屏幕</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-ls：类似于对查找到的文件执行<code>ls -l</code>命令</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-delete：删除查找到的文件，操作有风险，确认许谨慎</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-fls /path/to/somefile：查找到的所有文件的长格式信息保存至指定文件中</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-ok COMMAND {} \;：对查找到的每个文件执行由COMMAND指定的命令，对于每个文件执行命令之前，都需要交互式要求用户确认。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-exec COMMAND {} \;：对查找到的每个文件执行由COMMAND指定的命令，不需要确认。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：find查找到的文件传递至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的命令，但是有些命令不能接受过多的参数，此时命令执行可能会失败，另一种方式可规避此问题：<code>find | xargs COMMAND</code></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如：<code>find /tmp -amin -5 | xargs cat</code></p><p>&emsp;&emsp;对于find的应用举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost tmp]# #1、查找/var目录下属主为root，且属组为mail的所有文件或目录</span><br><span class="line">[root@localhost tmp]# find /var -user root -a -group mail -ls</span><br><span class="line">201327649    0 drwxrwxr-x   2 root     mail           43 Jul 25 17:30 /var/spool/mail</span><br><span class="line">207496332  232 -rw-------   1 root     mail       235791 Jul 25 17:30 /var/spool/mail/root</span><br><span class="line">[root@localhost tmp]# #2、查找/usr目录下不属于root，bin或zhangshuo的所有文件或目录</span><br><span class="line">[root@localhost tmp]# find /usr/ -not -user root -a -not -user bin -a -not -user zhangshuo -ls | less</span><br><span class="line">[root@localhost tmp]# #3、查找/etc目录下最近一周内其内容修改过，同时属主不为root，也不是zhangshuo的文件或目录</span><br><span class="line">[root@localhost tmp]# find /etc/ -mtime -7 -not \( -user root -o -user zhangshuo \) -ls</span><br><span class="line">[zhangshuo@localhost ~]$ #4、查找当前系统上没有属主或属组，且最近一周内曾被访问过的文件</span><br><span class="line">[root@localhost ~]# find / -nouser -a -nogroup -a -atime -7 -ls</span><br><span class="line">[zhangshuo@localhost ~]$ #5、查找/etc目录下大于1M且类型为普通文件的所有文件</span><br><span class="line">[zhangshuo@localhost ~]$ sudo find /etc/ -size +1M -a -type f -ls</span><br><span class="line">[zhangshuo@localhost ~]$ #6、查找/etc目录下所有用户都没有写权限的文件</span><br><span class="line">[zhangshuo@localhost ~]$ sudo find /etc/ -not -perm /222 -ls</span><br><span class="line"><span class="meta">#</span><span class="bash">备注：首先可以反过来想就是所有用户都有写权限则为-perm -222 此时再加not然后与的关系要转为或的关系</span></span><br><span class="line">[zhangshuo@localhost ~]$ #7、查找/etc目录下至少有一类用户没有执行权限的文件</span><br><span class="line">[zhangshuo@localhost ~]$ sudo find /etc/ -not -perm -111 -ls</span><br><span class="line"><span class="meta">#</span><span class="bash">备注：首先找对立事件则为至少有一类用户用执行权限则为-perm /111 此时再求对立事件即可则为-not -perm -111</span></span><br><span class="line">[zhangshuo@localhost ~]$ #8、查找/etc/init.d 目录下所有用户都有执行权限，且其它用户都有写权限的文件</span><br><span class="line">[zhangshuo@localhost ~]$ sudo find /etc/init.d/ -perm -113 -ls</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;</p><h2 id="文件特殊权限及if条件语句"><a href="#文件特殊权限及if条件语句" class="headerlink" title="文件特殊权限及if条件语句"></a>文件特殊权限及if条件语句</h2><h3 id="linux文件系统上的特殊权限"><a href="#linux文件系统上的特殊权限" class="headerlink" title="linux文件系统上的特殊权限"></a>linux文件系统上的特殊权限</h3><p>&emsp;&emsp;SUID，SGID，Sticky</p><p>&emsp;&emsp;1、安全上下文</p><p>&emsp;&emsp;&emsp;&emsp;前提：进程有属主和属组，文件有属主和属组</p><p>&emsp;&emsp;&emsp;&emsp;（1）、任何一个可执行程序文件能不能启动为进程，取决于发起者对程序文件是否拥有执行权限</p><p>&emsp;&emsp;&emsp;&emsp;（2）、启动为进程之后，其进程的属主为发起者，进程的属主为发起者所属的组</p><p>&emsp;&emsp;&emsp;&emsp;（3）、进程访问文件时的权限，取决于进程的发起者</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（a）、进程的发起者，同文件的属主，则应用文件属主权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（b）、进程的发起者，同文件的属组，则应用文件属组权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（c）、如果都不属于则应用文件的其它权限</p><p>&emsp;&emsp;2、SUID</p><p>&emsp;&emsp;&emsp;&emsp;（1）、任何一个可执行程序文件能不能启动为进程取决于发起者对程序文件是否拥有执行权限</p><p>&emsp;&emsp;&emsp;&emsp;（2）、启动为进程之后，其进程的属主为原程序文件的属主</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如/usr/bin/passwd文件就具有SUID权限，所以普通用户才可以使用该命令进行密码的修改，并将修改后的文件写入到/etc/shadow文件中</p><p>&emsp;&emsp;&emsp;&emsp;权限设定：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod u+s ：设置该权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod u-s ：取消该权限</p><p>&emsp;&emsp;3、SGID</p><p>&emsp;&emsp;&emsp;&emsp;默认情况下，用户创建文件时其属组为此用户所属的基本组，一旦某目录被设定了SGID，则对此目录有写权限的用户在此目录中创建的文件所属的组为此目录的属组</p><p>&emsp;&emsp;&emsp;&emsp;权限设定：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod g+s DIR…</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod g-s DIR…</p><p>&emsp;&emsp;4、sticky</p><p>&emsp;&emsp;&emsp;&emsp;对于一个多人可写的目录，如果设置了sticky，则每个用户仅能删除自己的文件</p><p>&emsp;&emsp;&emsp;&emsp;权限设定：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod o+t DIR…</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;chmod o-t DIR…</p><p>&emsp;&emsp;&emsp;&emsp;注意，以上三个权限也可以使用一个八进制数进行表示，chmod 1777 /tmp/a.txt表示该文件具有sticky同时读写执行都为777</p><p>&emsp;&emsp;5、几个权限位映射</p><p>&emsp;&emsp;&emsp;&emsp;SUID：user占据属主的执行权限位</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;S：属主没有x权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;s：属主具有x权限</p><p>&emsp;&emsp;&emsp;&emsp;SGID：group占据属组的执行权限位</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;S：属主没有x权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;s：属主具有 x权限</p><p>&emsp;&emsp;&emsp;&emsp;sticky：other占据 other的执行权限位</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;T：属主没有x权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;t：属主具有x权限</p><h3 id="bash脚本编程"><a href="#bash脚本编程" class="headerlink" title="bash脚本编程"></a>bash脚本编程</h3><p>&emsp;&emsp;过程式编程语言：</p><p>&emsp;&emsp;&emsp;&emsp;顺序执行：</p><p>&emsp;&emsp;&emsp;&emsp;选择执行：</p><p>&emsp;&emsp;&emsp;&emsp;循环执行：</p><p>&emsp;&emsp;选择执行：</p><p>&emsp;&emsp;&emsp;&emsp;条件判断，控制结构</p><p>&emsp;&emsp;&emsp;&emsp;单分支的if语句<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if 判断条件; then<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;statement1<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;statement2<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;  …<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;fi</p><p>&emsp;&emsp;&emsp;&emsp;双分支的if语句：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if 判断条件; then<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;statement1<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;statement1</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;else<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;statement3</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;fi</p><p>&emsp;&emsp;## linux磁盘管理</p><p>&emsp;&emsp;设备文件：关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信</p><p>&emsp;&emsp;&emsp;&emsp;设备号：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;主设备号：major number 标识设备类型</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;次设备号：minor number 标识同一类型下的不同设备，这样系统可以只调用一个驱动程序即可</p><p>&emsp;&emsp;&emsp;&emsp;对于设备文件来说，只有元数据而没有数据</p><p>&emsp;&emsp;&emsp;&emsp;</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brw-rw----. 1 root    disk      8,   0 Aug  7 08:52 sda #该文件为块设备文件，主设备号为8次设备号为0而没有大小</span><br><span class="line">brw-rw----. 1 root    disk      8,   1 Aug  7 08:52 sda1</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;硬盘接口类型：</p><p>&emsp;&emsp;&emsp;&emsp;IDE：并口通信&emsp;&emsp;接口最大速度133MB/s</p><p>&emsp;&emsp;&emsp;&emsp;SCSI：并口通信&emsp;&emsp;接口最大速度640MB/s</p><p>&emsp;&emsp;&emsp;&emsp;SATA：串口通信&emsp;&emsp;接口最大速度6Gb/s</p><p>&emsp;&emsp;&emsp;&emsp;SAS：串口通信&emsp;&emsp;接口最大速度6Gb/s</p><p>&emsp;&emsp;&emsp;&emsp;USB：串口通信&emsp;&emsp;接口最大速度5Gb/s</p><p>&emsp;&emsp;&emsp;&emsp;注意：上面的速度只是该接口的理论最大速度，而实际速度还要取决于硬件的读写性能</p><p>&emsp;&emsp;硬盘设备的设备文件命名：</p><p>&emsp;&emsp;&emsp;&emsp;centos5：IDE硬盘的命名为/dev/hd</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;SCSI，SATA，SAS，USB都会以/dev/sd来表示</p><p>&emsp;&emsp;&emsp;&emsp;对于centos6，7硬盘都表示为为/dev/sd</p><p>&emsp;&emsp;&emsp;&emsp;对于不同的硬盘用a-z来表示</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如/dev/sda，/dev/sdb</p><p>&emsp;&emsp;&emsp;&emsp;对于同一硬盘的不同分区用1，2，3来表示</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如/dev/sda1，/dev/sda2等</p><p>&emsp;&emsp;机械硬盘的分区方式：</p><p>&emsp;&emsp;&emsp;&emsp;对于机械硬盘来说，在磁盘的0磁道，0扇区用来保存磁盘的分区信息，每个扇区有512字节这512个字节用处如下：</p><p>&emsp;&emsp;&emsp;&emsp;前446字节用于MBR：Master Boot Record叫做主引导记录</p><p>&emsp;&emsp;&emsp;&emsp;下面64字节用于存放分区表，每个分区用16个字节来表示，所以64个字节只能表示4个分区</p><p>&emsp;&emsp;&emsp;&emsp;最后2个字节用于表示该分区表的有效性。</p><p>&emsp;&emsp;&emsp;&emsp;对于这种方式的分区方式，每个硬盘只能用于4个分区，显然不能满足需求，此时可以使用扩展分区，就是其中的16字节并不表示分区情况，而表示了一个映射，映射到一个更大的地方来表示更多的分区。</p><p>&emsp;&emsp;&emsp;&emsp;所以通常会分为3个主分区和一个扩展分区，扩展分区只能有一个，在扩展分区中其它分区则为逻辑分区，对于逻辑分区来说可以有无限个。</p><p>&emsp;&emsp;分区管理工具：fdisk ，parted，sfdisk</p><p>&emsp;&emsp;&emsp;&emsp;fdisk：对于单个硬盘来说，最多只能管理15个分区</p><p>&emsp;&emsp;&emsp;&emsp;fdisk -l [-u][device…] ：查看分区情况</p><p>&emsp;&emsp;&emsp;&emsp;fdisk Device</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;子命令：管理功能</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;p：print，显示以有分区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;n：new，创建新的分区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d：delete，删除分区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;w：write，写入磁盘并退出</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;q：quit，放弃更新并推出</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;m：获取帮助</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l：列表所有分区id</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;t：调整分区id</p><p>&emsp;&emsp;&emsp;&emsp;查看内核是否已经识别新的分区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;cat /proc/partations</p><p>&emsp;&emsp;&emsp;&emsp;通知内核重新读取硬盘分区表</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;partx -a /dev/sda</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;partx -a -n 4:6 /dev/sdb ：使用-n选项来指定读取分区</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-f：force</p><h2 id="Linux文件系统管理"><a href="#Linux文件系统管理" class="headerlink" title="Linux文件系统管理"></a>Linux文件系统管理</h2><p>&emsp;&emsp;Linux文件系统：ext2，ext3，ext4，xfs，btrfs，reiserfs，jfs</p><p>&emsp;&emsp;&emsp;&emsp;swap：交换分区</p><p>&emsp;&emsp;&emsp;&emsp;光盘：iso9600</p><p>&emsp;&emsp;windows文件系统：fat32，ntfs</p><p>&emsp;&emsp;unix文件系统：FFS，UFS，JFS2</p><p>&emsp;&emsp;网络文件系统：NFS，CIFS（网上邻居文件系统）</p><p>&emsp;&emsp;集群文件系统：红帽的GFS2，OCFS2</p><p>&emsp;&emsp;根据其是否支持日志功能分为</p><p>&emsp;&emsp;&emsp;&emsp;日志型文件系统：ext3，ext4，xfs…</p><p>&emsp;&emsp;&emsp;&emsp;非日志型文件系统：ext2，vfat</p><p>&emsp;&emsp;文件系统的组成部分：</p><p>&emsp;&emsp;&emsp;&emsp;内核中的模块：ext4，xfs，vfat</p><p>&emsp;&emsp;&emsp;&emsp;查看内核模块命令：lsmod</p><p>&emsp;&emsp;&emsp;&emsp;用户空间的管理工具：mkfs.ext4，mkfs.xfs，mkfs.vfat</p><p>&emsp;&emsp;linux的虚拟文件系统：VFS</p><p>&emsp;&emsp;&emsp;&emsp;作用将各种文件系统的接口同一起来用于，方便程序员进行程序的开发</p><p>&emsp;&emsp;创建文件系统：</p><p>&emsp;&emsp;&emsp;&emsp;查看当前系统所支持的文件系统：cat /proc/filesystems</p><p>&emsp;&emsp;&emsp;&emsp;blkid /dev/DEVICE 查看文件系统信息</p><p>&emsp;&emsp;&emsp;&emsp;创建文件系统的方法：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、mkfs.FS_TYPE /dev/DEVICE</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ext4;ext2;ext3;xfs;btrfs;vfat</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、mkfs -t FS_TYPE /dev/DEVICE</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mkfs -t xfs  /dev/sda5</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L MYDATA：指明分区的标签</p><p>&emsp;&emsp;&emsp;&emsp;ext系列文件系统专用管理工具：mke2fs</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-t {ext2|ext3|ext4}</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-b {1024|2048|4096}</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L “LABEL”</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-j：日志功能，相当于-t ext3</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;mkfs.ext3=mkft -t ext3=mke2fs -j =mke2fs -t ext3</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-m #:制定预留给超级用户的块数百分比，默认为5%</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-i #:用于指定为多少个字节空间创建一个inode，默认为8192，这里给出的数值应该为块大小的2^n倍</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-N #：为分区数据空间指定创建多少个inode</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-F：强制创建文件系统</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-E：用户指定额为文件系统属性</p><p>&emsp;&emsp;blkid：块设备属性信息查看</p><p>&emsp;&emsp;&emsp;&emsp; blkid -L label | -U uuid</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-U：UUID根据指定的UUID来查找对应的设备</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L：LABEL根据指定的LABEL来查找对应的设备</p><p>&emsp;&emsp;e2label：管理ext系列文件系统的LABEL</p><p>&emsp;&emsp;&emsp;&emsp;e2label DEVICE [LABEL]</p><p>&emsp;&emsp;tune2fs：重新设定ext文件系统可调参数的值</p><p>&emsp;&emsp;&emsp;&emsp;-l：查看指定文件系统超级块信息</p><p>&emsp;&emsp;&emsp;&emsp;-L “LABEL”：修改卷标信息</p><p>&emsp;&emsp;&emsp;&emsp;-m #：修改预留给管理员的空间百分比</p><p>&emsp;&emsp;&emsp;&emsp;-j：将ext2升级为ext3</p><p>&emsp;&emsp;&emsp;&emsp;-r #:指定预留块数</p><p>&emsp;&emsp;&emsp;&emsp;-o:设定默认挂在格式&emsp;&emsp;</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;acl：开启acl功能，acl指访问控制列表，这里指文件系统而言</p><p>&emsp;&emsp;&emsp;&emsp;-U UUID：修改UUID号，该选项基本很少用，除非UUID号码重复时</p><p>&emsp;&emsp;dumpe2fs:显示文件属性信息<br>&emsp;&emsp;&emsp;&emsp;-h:只显示超级块信息</p><p>&emsp;&emsp;mkswap：创建交换分区</p><p>&emsp;&emsp;&emsp;&emsp;mkswap [options] device</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-L “LABEL”：指定卷标</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：前提要将其分区ID调整为82</p><p>&emsp;&emsp;文件系统检测：</p><p>&emsp;&emsp;&emsp;&emsp;fsck：检查并修复Linux文件系统<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-t FSTYPE:文件系统类型<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a :自动修复<br>&emsp;&emsp;<br>&emsp;&emsp;&emsp;&emsp;e2fsck:专用于修复ext2/ext3文件系统<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-f:强制检查<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-p:自动修复<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a:自动修复</p><p>-EOF</p><p>&emsp;&emsp;&emsp;&emsp;</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第7集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;find命令、if语句、磁盘管理、文件系统管理&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第6集</title>
    <link href="https://zhangdashuo.github.io/2018/07/27/redhat06/"/>
    <id>https://zhangdashuo.github.io/2018/07/27/redhat06/</id>
    <published>2018-07-27T13:30:20.000Z</published>
    <updated>2018-08-07T09:40:59.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第6集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>egrep、bash环境配置及脚本、vim编辑器<br><a id="more"></a></excerpt></p><h2 id=""><a href="#" class="headerlink" title=""></a><the rest="" of="" contents="" |="" 余下全文=""></the></h2><h2 id="egrep及bash中的变量"><a href="#egrep及bash中的变量" class="headerlink" title="egrep及bash中的变量"></a>egrep及bash中的变量</h2><h3 id="egrep及扩展的正则表达式"><a href="#egrep及扩展的正则表达式" class="headerlink" title="egrep及扩展的正则表达式"></a>egrep及扩展的正则表达式</h3><p>&emsp;&emsp;egrep = grep -E</p><p>&emsp;&emsp;egrep [OPTIONS] PATTERN [FILE…]</p><p>&emsp;&emsp;fgrep：不支持正则表达式，而是直接搜索，这样速度较快</p><p>&emsp;&emsp;扩展正则表达式的元字符：</p><p>&emsp;&emsp;&emsp;&emsp;字符匹配：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.，[]，[^]</p><p>&emsp;&emsp;&emsp;&emsp;次数匹配：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;*，?，+，{m}，{m,}，{m,n}，{0,n}</p><p>&emsp;&emsp;&emsp;&emsp;位置锚定：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;^，$，\&lt;，\&gt;，\b，</p><p>&emsp;&emsp;&emsp;&emsp;分组：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;()，后向引用：\1，\2，…</p><p>&emsp;&emsp;&emsp;&emsp;或者：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;a|b：C|cat 表示C或者cat而不是表示Cat或cat如果要表示这种需要：(C|c)at</p><p>&emsp;&emsp;&emsp;&emsp;egrep举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ #1、显示当前系统root，git，或zhangshuo用户的默认shell和UID</span><br><span class="line">[zhangshuo@localhost ~]$ egrep "^(root|git|zhangshuo)\&gt;" /etc/passwd | cut -d : -f 1,3,7</span><br><span class="line">root:0:/bin/bash</span><br><span class="line">zhangshuo:1000:/bin/bash</span><br><span class="line">[zhangshuo@localhost ~]$ #2、找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号的行</span><br><span class="line">[zhangshuo@localhost ~]$ egrep "\&lt;[[:alpha:]]+\&gt;\(\)" /etc/rc.d/init.d/functions </span><br><span class="line">checkpid() &#123;</span><br><span class="line">daemon() &#123;</span><br><span class="line">killproc() &#123;</span><br><span class="line">[zhangshuo@localhost ~]$ #3、使用echo输出一路径，使用egrep取出其基名</span><br><span class="line">[zhangshuo@localhost ~]$ echo "/etc//passwd/" | egrep -o "[^/]+/?$" | cut -d / -f 1</span><br><span class="line">passwd</span><br><span class="line">[zhangshuo@localhost ~]$ echo "/etc//passwd/" | egrep -o "/[[:alpha:]]+/?$" | cut -d / -f 2</span><br><span class="line">passwd</span><br><span class="line">[zhangshuo@localhost ~]$ #4、找出ifconfig命令结果中1-255之间的数值</span><br><span class="line">[zhangshuo@localhost ~]$ ifconfig | egrep -o "\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;"</span><br><span class="line">10</span><br><span class="line">2</span><br><span class="line">15</span><br><span class="line">255</span><br><span class="line">255</span><br><span class="line">[zhangshuo@localhost ~]$ #5、找出ifocnifg命令结果中的IP地址</span><br><span class="line">[zhangshuo@localhost ~]$ ifconfig | egrep -o "(\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;.)&#123;3&#125;\&lt;([1-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;"</span><br><span class="line">10.8.76.166</span><br><span class="line">10.8.255.255</span><br><span class="line">192.168.122.1</span><br><span class="line">192.168.122.255</span><br></pre></td></tr></table></figure><h3 id="bash的基础特性（4）"><a href="#bash的基础特性（4）" class="headerlink" title="bash的基础特性（4）"></a>bash的基础特性（4）</h3><p>&emsp;&emsp;变量类型：决定了数据存储格式，存储空间大小，参与运算种类</p><p>&emsp;&emsp;&emsp;&emsp;字符型：</p><p>&emsp;&emsp;&emsp;&emsp;数值型：数值型又包括</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;整型：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;浮点型：</p><p>&emsp;&emsp;对于强类型的语言：定义变量时必须指定类型，参与运算必须符合类型要求，调用未声明的变量会报错</p><p>&emsp;&emsp;对于若类型的语言（shell）：无需指定类型，默认均为字符型，参与运算会自动进行隐式类型转换，变量无需事先定义可直接调用</p><p>&emsp;&emsp;bash中的变量的种类：</p><p>&emsp;&emsp;&emsp;&emsp;本地变量：生效范围为当前shell进程，对当前shell之外的其它shell进程包括当前shell的子进程均无效</p><p>&emsp;&emsp;&emsp;&emsp;环境变量：生效范围为当前shell进程及其子进程</p><p>&emsp;&emsp;&emsp;&emsp;局部变量：生效范围为当前shell进程中某代码片段（通常指函数）</p><p>&emsp;&emsp;&emsp;&emsp;位置变量：$1，$2，…来表示用于让脚本代码中调用通过命令行传递给它的参数</p><p>&emsp;&emsp;&emsp;&emsp;特殊变量：$?，$0，$#，$*，$@</p><p>&emsp;&emsp;本地变量：</p><p>&emsp;&emsp;&emsp;&emsp;变量赋值：name=”VALUE”</p><p>&emsp;&emsp;&emsp;&emsp;对于VALUE可以使用引用：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）：可以是直接字串：name=”username”</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）：变量引用：name=”$username”</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（3）：命令引用：name=`COMMAND`或name=$(COMMAND)</p><p>&emsp;&emsp;&emsp;&emsp;变量引用：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;””：弱引用，其中的变量引用会被替换为变量值</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;’’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串本身</p><p>&emsp;&emsp;&emsp;&emsp;显示定义的所有变量：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;命令：set</p><p>&emsp;&emsp;&emsp;&emsp;销毁变量：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;命令：unset name</p><p>&emsp;&emsp;环境变量：</p><p>&emsp;&emsp;&emsp;&emsp;变量声明和赋值</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;export name=VALUE</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;declare -x name=VALUE</p><p>&emsp;&emsp;&emsp;&emsp;变量引用：$name，${name}</p><p>&emsp;&emsp;&emsp;&emsp;显示所有的环境变量：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;命令：<code>export</code> <code>env</code> <code>printenv</code></p><p>&emsp;&emsp;&emsp;&emsp;销毁变量： unset name</p><p>&emsp;&emsp;&emsp;&emsp;bash中许多内建的环境变量：PATH,SHELL,UID,HISTSIZE,HISTFILE,HISTCONTROL,OLD,PWD,HOME,PS1等</p><p>&emsp;&emsp;变量的命名法则：</p><p>&emsp;&emsp;&emsp;&emsp;1、不能使用程序中的保留字：例如if，for等</p><p>&emsp;&emsp;&emsp;&emsp;2、只能使用数字，字母及下划线，且不能以数字开头</p><p>&emsp;&emsp;&emsp;&emsp;3、尽量做到见名知义</p><p>&emsp;&emsp;只读变量：</p><p>&emsp;&emsp;&emsp;&emsp;使用readonly name 来定义或</p><p>&emsp;&emsp;&emsp;&emsp;declare -r name</p><p>&emsp;&emsp;&emsp;&emsp;注意：只读变量只要被定义则再改shell进程结束之前禁止修改和撤销</p><p>&emsp;&emsp;位置变量：</p><p>&emsp;&emsp;&emsp;&emsp;在脚本代码中调用通过命令行传递给脚本的参数</p><p>&emsp;&emsp;&emsp;&emsp;$1，$2，…对应调用第1个，第2个参数</p><p>&emsp;&emsp;特殊变量：</p><p>&emsp;&emsp;&emsp;&emsp;$?：命令执行状态返回值</p><p>&emsp;&emsp;&emsp;&emsp;$0：命令本身</p><p>&emsp;&emsp;&emsp;&emsp;$*：传递给脚本的所有参数当作一个字串</p><p>&emsp;&emsp;&emsp;&emsp;$@：传递给脚本的所有参数，每一个当作一个字串</p><p>&emsp;&emsp;&emsp;&emsp;$#：传递给脚本的参数的个数</p><p>&emsp;&emsp;&emsp;&emsp;在脚本中可以使用shift [n]来进行轮换</p><h2 id="bash环境配置及脚本"><a href="#bash环境配置及脚本" class="headerlink" title="bash环境配置及脚本"></a>bash环境配置及脚本</h2><h3 id="bansh环境配置"><a href="#bansh环境配置" class="headerlink" title="bansh环境配置"></a>bansh环境配置</h3><p>&emsp;&emsp;bash的配置文件</p><p>&emsp;&emsp;&emsp;&emsp;按生效范围划分存在两类：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;全局配置：/etc/profile /etc/profile.d/*.sh /etc/bashrc</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;个人配置：~/.bashrc ~/.bash_profile</p><p>&emsp;&emsp;&emsp;&emsp;按功能划分：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;profile类：为交互式登陆的shell提供配置</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;功用：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、定义环境变量</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、运行命令或脚本</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;bashrc类：为非交互式登陆的shell提供配置</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;功用：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、定义命令别名</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、定义本地变量</p><p>&emsp;&emsp;&emsp;&emsp;shell登陆类别划分</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;交互式登陆：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;直接通过终端输入账号密码登陆</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;使用su - username或su -l username切换致的用户</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;非交互式登陆</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;su username</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;图形界面下打开的终端</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;执行脚本运行的终端</p><p>&emsp;&emsp;&emsp;&emsp;登陆式shell获取配置文件次序</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/etc/profile–&gt;/etc/profile.d/*.sh–&gt;~/.bash_profile–&gt;~/.bashrc–&gt;/etc/bashrc</p><p>&emsp;&emsp;&emsp;&emsp;非登陆式shell获取配置文件次序</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;~/.bashrc–&gt;/etc/bashrc–&gt;/etc/profile.d/*.sh</p><h3 id="bash中的算数运算符"><a href="#bash中的算数运算符" class="headerlink" title="bash中的算数运算符"></a>bash中的算数运算符</h3><p>&emsp;&emsp;（1）、let var=算术表达式</p><p>&emsp;&emsp;（2）、var=$[算术表达式]</p><p>&emsp;&emsp;（3）、var=$((算术表达式))</p><p>&emsp;&emsp;（4）、var=$(expr arg1 arg2 arg3 …)</p><p>&emsp;&emsp;各算法运算表示如下</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ A=3</span><br><span class="line">[zhangshuo@localhost ~]$ B=5</span><br><span class="line">[zhangshuo@localhost ~]$ let C=$A+$B</span><br><span class="line">[zhangshuo@localhost ~]$ echo $C</span><br><span class="line">8</span><br><span class="line">[zhangshuo@localhost ~]$ echo "$[$A+$B]"</span><br><span class="line">8</span><br><span class="line">[zhangshuo@localhost ~]$ echo "$(($A+$B))"</span><br><span class="line">8</span><br><span class="line">[zhangshuo@localhost ~]$ echo "$(expr $A \* $B)"</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：乘法符号有些场景中需要转义</p><p>&emsp;&emsp;bash有内建的随机数生成器：$RANDOM 例如取出1-60中的随机数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ echo "$[$RANDOM%60+1]"</span><br><span class="line">35</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;增强型赋值：let count+=1 ，let count++ ，count=$[$count+1]可以实现变量自加一</p><p>&emsp;&emsp;对于数值计算举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost bin]$ #1、写一个脚本，计算/etc/passwd文件中的第10个用户和第20个用户的id之和</span><br><span class="line">[zhangshuo@localhost bin]$ pwd</span><br><span class="line">/home/zhangshuo/bin</span><br><span class="line">[zhangshuo@localhost bin]$ vim sumid.sh</span><br><span class="line">[zhangshuo@localhost bin]$ cat sumid.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by 张硕 20180731</span></span><br><span class="line">user10id=$(head -10 /etc/passwd | tail -1 | cut -d : -f 3)</span><br><span class="line">user20id=$(head -20 /etc/passwd | tail -1 | cut -d : -f 3)</span><br><span class="line">idsum1020=$[$user10id+$user20id]</span><br><span class="line">echo "id20 and id10 id sum is $idsum1020"</span><br><span class="line">[zhangshuo@localhost bin]$ chmod +x sumid.sh </span><br><span class="line">[zhangshuo@localhost bin]$ ./sumid.sh </span><br><span class="line">id20 and id10 id sum is 70</span><br><span class="line">[zhangshuo@localhost bin]$ #2、写一个脚本，传递两个文件路径作为参数给脚本，计算这两个文件中所有空白行之和</span><br><span class="line">[zhangshuo@localhost bin]$ vim blackline.sh</span><br><span class="line">[zhangshuo@localhost bin]$ cat blackline.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by 张硕 20180731</span></span><br><span class="line">file1spacenum=$(grep "^[[:space:]]*$" $1 | wc -l)</span><br><span class="line">file2spacenum=$(grep "^[[:space:]]*$" $2 | wc -l)</span><br><span class="line">numsum=$[$file1spacenum+$file2spacenum]</span><br><span class="line">echo "space line num is $numsum"</span><br><span class="line">[zhangshuo@localhost bin]$ chmod +x blackline.sh </span><br><span class="line">[zhangshuo@localhost bin]$ ./blackline.sh /etc/passwd /etc/rc.d/init.d/functions </span><br><span class="line">space line num is 90</span><br><span class="line">[zhangshuo@localhost bin]$ #3、统计/etc/，/var/，/usr目录共有多少个一级子目录和文件</span><br><span class="line">[zhangshuo@localhost bin]$ vim gitline.sh</span><br><span class="line">[zhangshuo@localhost bin]$ cat gitline.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by 张硕 20180731</span></span><br><span class="line">etclines=$(ls /etc | wc -l)</span><br><span class="line">varlines=$(ls /var | wc -l)</span><br><span class="line">usrlines=$(ls /usr | wc -l)</span><br><span class="line">linesnum=$[$etclines + $varlines + $usrlines]</span><br><span class="line">echo "lines sum is $linesnum"</span><br><span class="line">[zhangshuo@localhost bin]$ chmod +x gitline.sh </span><br><span class="line">[zhangshuo@localhost bin]$ ./gitline.sh </span><br><span class="line">lines sum is 324</span><br></pre></td></tr></table></figure><h3 id="bash中的条件测试"><a href="#bash中的条件测试" class="headerlink" title="bash中的条件测试"></a>bash中的条件测试</h3><p>&emsp;&emsp;判断某需求是否满足，需要由测试机制来实现</p><p>&emsp;&emsp;注意：专用的测试表达式需要由测试命令辅助完成测试过程</p><p>&emsp;&emsp;测试命令：</p><p>&emsp;&emsp;&emsp;&emsp;test EXPRESSION</p><p>&emsp;&emsp;&emsp;&emsp;[ EXPRESSION ]</p><p>&emsp;&emsp;&emsp;&emsp;[[ EXPRESSION ]]</p><p>&emsp;&emsp;&emsp;&emsp;注意：EXPRESSION前后必须有空白字符</p><p>&emsp;&emsp;bash的测试类型：</p><p>&emsp;&emsp;&emsp;&emsp;数值测试：</p><p>&emsp;&emsp;&emsp;&emsp;字符串测试：</p><p>&emsp;&emsp;&emsp;&emsp;文件测试：</p><p>&emsp;&emsp;数值测试：</p><p>&emsp;&emsp;&emsp;&emsp;-gt：是否大于</p><p>&emsp;&emsp;&emsp;&emsp;-le：是否小于等于</p><p>&emsp;&emsp;&emsp;&emsp;-ge：是否大于等于</p><p>&emsp;&emsp;&emsp;&emsp;-eq：是否相等</p><p>&emsp;&emsp;&emsp;&emsp;-ne：是否不想等</p><p>&emsp;&emsp;&emsp;&emsp;-lt：是否小于</p><p>&emsp;&emsp;字符串测试：</p><p>&emsp;&emsp;&emsp;&emsp;==：是否等于</p><p>&emsp;&emsp;&emsp;&emsp;&gt;：是否大于</p><p>&emsp;&emsp;&emsp;&emsp;&lt;：是否小于</p><p>&emsp;&emsp;&emsp;&emsp;!=：是否不等于</p><p>&emsp;&emsp;&emsp;&emsp;=~：左侧字符串是否能够被右侧的PATTERN所匹配到</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：此表达式一般用于[[]]测试符号中</p><p>&emsp;&emsp;&emsp;&emsp;-z “STRING”：测试字符串是否为空，空则为真，不空则为假</p><p>&emsp;&emsp;&emsp;&emsp;-n “STRING”：测试字符串是否不空，不空则为真，空则为假</p><p>&emsp;&emsp;bash自定义退出状态码</p><p>&emsp;&emsp;&emsp;&emsp;在脚本中需要退出的位置使用命令<code>exit [n]</code>即可自定义退出状态码</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：脚本中一旦遇到exit命令，脚本会立即终止，终止退出状态取决于exit命令后面的数字</p><p>&emsp;&emsp;&emsp;&emsp;注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码</p><p>&emsp;&emsp;&emsp;&emsp;脚本中自定义错误码举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost bin]$ #写一个脚本，接受一个文件路径作为参数，如果参数个数小于1，则提示用户至少应给一个参 数，并立即退出，如果参数个数不小于1，则显示第一个参数所指向的文件中的空白行数</span><br><span class="line">[zhangshuo@localhost bin]$ vim myexit.sh</span><br><span class="line">[zhangshuo@localhost bin]$ cat myexit.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">by zhangshuo 20180731</span></span><br><span class="line">[ $# -lt 1 ] &amp;&amp; echo "至少应给一个参数" &amp;&amp; exit 2</span><br><span class="line">spacelinenum=$(grep "^[[:space:]]*$" $1 | wc -l)</span><br><span class="line">echo "first file space line num is $spacelinenum"</span><br><span class="line">[zhangshuo@localhost bin]$ chmod +x myexit.sh </span><br><span class="line">[zhangshuo@localhost bin]$ ./myexit.sh </span><br><span class="line">至少应给一个参数</span><br><span class="line">[zhangshuo@localhost bin]$ echo $?</span><br><span class="line">2</span><br><span class="line">[zhangshuo@localhost bin]$ ./myexit.sh /etc/rc.d/init.d/functions </span><br><span class="line">first file space line num is 90</span><br></pre></td></tr></table></figure><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>vim简单介绍</p><p>&emsp;&emsp;vi：Visual Interface 可视化接口编辑器</p><p>&emsp;&emsp;文本编辑器种类：</p><p>&emsp;&emsp;&emsp;&emsp;行编辑器：sed</p><p>&emsp;&emsp;&emsp;&emsp;全屏编辑器：nano，vi等</p><p>&emsp;&emsp;vim：vi iMproved ：模式化编辑器</p><p>&emsp;&emsp;&emsp;&emsp;基本模式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;编辑模式，命令模式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;输入模式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;末行模式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;内置的命令行接口</p><p>&emsp;&emsp;打开文件：</p><p>&emsp;&emsp;&emsp;&emsp;vim [OPTION]…FILE…</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+#：打开文件后，直接让光标处于第#行的行首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+/PATTERN：打开文件后，直接让光标处于第一个被PATTERN匹配到的行首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;+：直接到文件末尾</p><p>&emsp;&emsp;模式转换：</p><p>&emsp;&emsp;&emsp;&emsp;编辑模式–&gt;输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;i：insert，在光标所在处转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;a：append，在光标所在处后面转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;o：在当前光标所在行的下方打开一个新行转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;I：在当前光标所在行的行首转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;A：在当前光标所在行的行尾转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;O：在当前光标所在行的上方打开一个新行转为输入模式</p><p>&emsp;&emsp;&emsp;&emsp;输入模式–&gt;编辑模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;按ESC键即可</p><p>&emsp;&emsp;&emsp;&emsp;编辑模式–&gt;末行模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:</p><p>&emsp;&emsp;&emsp;&emsp;末行模式–&gt;编辑模式</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;按ESC键，一次不行就多按几次</p><p>&emsp;&emsp;关闭文件：</p><p>&emsp;&emsp;&emsp;&emsp;在末行模式下：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:q 退出</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:q! 强制退出，丢弃做出的修改</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:wq 保存退出</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:x 保存退出</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:w /PATH/TO/SOMEWHERE 保存文件内容到其他文件，相当于office下的另存为</p><p>&emsp;&emsp;&emsp;&emsp;在编辑模式下：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ZZ 按两次大写的Z直接保存退出</p><p>&emsp;&emsp;光标跳转：</p><p>&emsp;&emsp;&emsp;&emsp;字符间跳转：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;h：光标向左移动一个字符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;j：光标向上移动一行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;k：光标向下移动一行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;l：光标向右移动一个字符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;以上命令还可以和数字组合：# COMMAND 跳转由#指定的个数的字符</p><p>&emsp;&emsp;&emsp;&emsp;单词间跳转：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;w：移动到下一个单次的词首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e：移动到下一个单次的词尾</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b：移动到上一个单次的词首</p><p>&emsp;&emsp;&emsp;&emsp;行首行尾跳转：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;^：跳转至行首的第一个非空白字符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;0：跳转至绝对行首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$：跳转至行尾</p><p>&emsp;&emsp;&emsp;&emsp;行间跳转：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# G：跳转至由#指定行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;G：跳转至文件最后一行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;gg，或1G：跳转至文件第一行</p><p>&emsp;&emsp;&emsp;&emsp;句间移动：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;)：跳转至下一句句首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(：跳转至上一句的句首</p><p>&emsp;&emsp;&emsp;&emsp;段落间移动：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;{：移动到段首</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;}：移动到段尾</p><p>&emsp;&emsp;vim的编辑命令：</p><p>&emsp;&emsp;&emsp;&emsp;字符编辑：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;x：删除光标处的字符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;# x：删除光标处起始的#个字符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;xp：交换光标所在处的字符及其后面字符的位置</p><p>&emsp;&emsp;&emsp;&emsp;删除命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d：删除命令，可结合光标跳转字符，实现范围删除</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d$，d^，d0，dw，dw，de，db</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;也可以和数字键组合使用：# COMMAND</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;dd：删除一整行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#dd：实现多行删除</p><p>&emsp;&emsp;&emsp;&emsp;粘贴命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;p：缓冲区保存的如果为整行，则粘贴至当前光标所在行的下方，否则则粘贴至当前光标所在处的后面</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;P：缓冲区保存的如果为整行，则粘贴至当前光标所在行的上方，否则则粘贴至当前光标所在处的前面</p><p>&emsp;&emsp;&emsp;&emsp;复制命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;y：复制，使用同d一样</p><p>&emsp;&emsp;&emsp;&emsp;改变命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c：修改，相当于d命令后再进行输入，使用该命令也可以实现从编辑模式到输入模式的转换</p><p>&emsp;&emsp;&emsp;&emsp;替换命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;r：替换光标所在处的字符</p><p>&emsp;&emsp;&emsp;&emsp;可视化模式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;v：按字符选定</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;V：按行选定</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意：可视化模式选定范围后通常会和d，c，y命令进行组合</p><p>&emsp;&emsp;撤销此前的编辑：</p><p>&emsp;&emsp;&emsp;&emsp;u（undo）：撤销此前的操作</p><p>&emsp;&emsp;&emsp;&emsp;#u：撤销指定次数的操作</p><p>&emsp;&emsp;撤销此前的撤销：</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+r</p><p>&emsp;&emsp;重复前一个编辑操作：</p><p>&emsp;&emsp;&emsp;&emsp;.</p><p>&emsp;&emsp;翻屏操作：</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+f：向文件尾部翻一屏</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+b：向文件首部翻一屏</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+d：向文件尾部翻半屏</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+u：向文件首部翻半屏</p><p>&emsp;&emsp;vim自带的练习教程</p><p>&emsp;&emsp;&emsp;&emsp;vimtutor</p><p>&emsp;&emsp;vim中的末行模式：</p><p>&emsp;&emsp;&emsp;&emsp;内建的命令行接口</p><p>&emsp;&emsp;&emsp;&emsp;（1）地址定界</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:start_pos,end_pos</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#：具体第#行，例如2表示第2行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#,#：从左侧#表示行起始，到右侧#表示行结尾</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#,+#：从左侧#表示的行起始，加上右侧#表示的行数</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.：表示当前行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$：表示到最后一行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.,$-1：表示从当前行到倒数第二行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;%：全文，相当于1,$</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/pat1/,/pat2/：从第一次被pat1模式匹配到的行开始一直到第一次被pat2匹配到的行结束</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;使用方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后跟一个编辑命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d，y，w，/path/to/somewhere</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;r /path/from/somefile：在指定位置插入指定文件中的所有内容</p><p>&emsp;&emsp;&emsp;&emsp;（2）查找</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;和less命令的用法类似</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;/PATTERN</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;?PATTERN</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;n：与命令查找方向相同来查找下一个</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;N：与命令查找方向相反来查找下一个</p><p>&emsp;&emsp;&emsp;&emsp;（3）查找并替换</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;s：在末行模式下完成查找替换操作</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;s/要查找的内容/替换为的内容/修饰符</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;要查找的内容：可使用模式进行匹配</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;替换为的内容：不能使用模式，但可以使用\1，\2，等后向引用符号，还可以使用”&amp;”引用前面查找时查找到的整个内容</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;修饰符：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;i：忽略大小写</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;g：全局替换，默认情况下，每一行只替换第一次出现</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例如：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;.,$s/r\(..\)t/R\1t/g</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;%s/l…x/&amp;er/g</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1,10s/how/HOW/g</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找替换中的分隔符/可替换为其它字符，例如</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;s@@@ ,s###</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;查找替换举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ #1、复制/etc/grub2.cfg至/tmp/下，用查找替换命令删除/tmp/grub2.cfg文件中的行首的空白字符</span><br><span class="line">[zhangshuo@localhost ~]$ :%s/^[[:space:]]\+//g</span><br><span class="line">[zhangshuo@localhost ~]$ #2、复制/etc/rc.d/init.d/functions文件至/tpm目录，用查找替换命令为/tmp/functions的每 行开头为空白字符的行首添加一个#号</span><br><span class="line">[zhangshuo@localhost ~]$ :%s/^[[:space:]]\+/#&amp;/g</span><br></pre></td></tr></table></figure><h2 id="vim编辑器和bash条件测试"><a href="#vim编辑器和bash条件测试" class="headerlink" title="vim编辑器和bash条件测试"></a>vim编辑器和bash条件测试</h2><h3 id="vim的多文件模式"><a href="#vim的多文件模式" class="headerlink" title="vim的多文件模式"></a>vim的多文件模式</h3><p>&emsp;&emsp;vim打开多个文件方式</p><p>&emsp;&emsp;&emsp;&emsp;vim FILE1 FILE2 FILE3：使用vim同时打开多个文件可以在这多个文件之间进行复制粘贴等操作</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;：next下一个    ：prev上一个    ：first第一个    ：last最后一个    </p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;：wall保存所有    ：qall退处所有    ：wqall保存退出所有</p><p>&emsp;&emsp;窗口分割模式</p><p>&emsp;&emsp;&emsp;&emsp;vim -o|O FILE1 FILE2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-o：水平分割</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-O：垂直分割</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在窗口间切换：Ctrl+w，ARROW</p><p>&emsp;&emsp;单文件窗口分割</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+w，s：水平分割窗口</p><p>&emsp;&emsp;&emsp;&emsp;Ctrl+w，v：垂直分割窗口</p><p>&emsp;&emsp;定制vim的工作特性</p><p>&emsp;&emsp;&emsp;&emsp;配置文件：永久有效</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;全局配置：/etc/vimrc</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;个人配置：~/.vimrc该文件通常不存在需要自己手动建立</p><p>&emsp;&emsp;&emsp;&emsp;末行模式下配置：对当前vim有效</p><p>&emsp;&emsp;&emsp;&emsp;配置命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（1）、显示行号：set number，set nu</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;取消显示行号：set nonumber，set nonu</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（2）、括号匹配高亮显示：set showmatch，set sm</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;取消括号匹配高亮显示：set nosm</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（3）、自动缩进：set ai，取消自动缩进：set noai</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（4）、高亮搜索：set hlsearch，取消高亮搜索：set nohlsearch</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;（5）、忽略字符的大小写：set ic，取消：set noic</p><p>&emsp;&emsp;vim应用举例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ #1、复制/etc/rc.d/functions 文件至/tmp目录,替换/tmp/functions文件中的/etc/sysconfig/init为/var/log</span><br><span class="line">[zhangshuo@localhost ~]$ vim /tmp/functions</span><br><span class="line">:%s@/etc/sysconfig/init@/var/log@g</span><br><span class="line">[zhangshuo@localhost ~]$ #2、删除/tmp/functions文件中所有以#开头，且#后面至少有一个空白字符的行的行首的#号</span><br><span class="line">[zhangshuo@localhost ~]$ vim /tmp/functions</span><br><span class="line">:%s/^#\([[:space:]]\+\)/\1/g</span><br></pre></td></tr></table></figure><h3 id="bash条件测试"><a href="#bash条件测试" class="headerlink" title="bash条件测试"></a>bash条件测试</h3><p>&emsp;&emsp;测试方法：</p><p>&emsp;&emsp;&emsp;&emsp;test EXPRESSION</p><p>&emsp;&emsp;&emsp;&emsp;[ EXPRESSION ]</p><p>&emsp;&emsp;&emsp;&emsp;[[ EXPRESSION ]]</p><p>&emsp;&emsp;测试表达式的类别：</p><p>&emsp;&emsp;&emsp;&emsp;数值比较：（上面提到过了）</p><p>&emsp;&emsp;&emsp;&emsp;字符串比较：（上面提到过了）</p><p>&emsp;&emsp;&emsp;&emsp;文件测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;存在性测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a FILE：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-e FILE：文件存在性测试，存在为真，否则为假</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;存在及类别测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-b FILE：被测文件是否存在且为块设备文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-c FILE：被测文件是否存在且为字符设备文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-d FILE：被测文件是否存在且为目录文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-f FILE：被测文件是否存在且为普通文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-h FILE 或 -L FILE ：被测文件是否存在且为符号链接文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-p FILE：被测文件是否存在且为管道文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-S FILE：被测文件是否存在且为套接字文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;文件特殊权限测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-g FILE：被测文件是否存在且拥有sgid权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-u FILE：被测文件是否存在且拥有suid权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-k FILE：被测文件是否存在且拥有sticky权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;文件权限测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-r FILE：被测文件是否拥有读权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-w FILE：被测文件是否拥有写权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-x FILE：被测文件是否拥有可执行权限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;文件大小测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-s FILE：被测文件是否存在且非空</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;文件是否打开：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-t fd：fd表示文件描述符是否已经打开且与某终端相关</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-N FILE：文件自从上一次被读取之后是否被修改过</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-O FILE：当前有效用户是否为该文件的属主</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-G FILE：当前有效用户是否为改文件的属组</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;双目测试：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;FILE1 -ef FILE2：FILE1与FILE2是否指向同一个设备上的相同的inode</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;FILE1 -nt FILE2：FILE1是否新与FILE2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;FILE1 -ot FILE2：FILE1是否旧与FILE2</p><p>&emsp;&emsp;组合测试条件：</p><p>&emsp;&emsp;是基于逻辑运算来实现的</p><p>&emsp;&emsp;两种方式：</p><p>&emsp;&emsp;&emsp;&emsp;第一种方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;COMMAND1 &amp;&amp; COMMAND2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;COMMAND2 || COMMAND2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;!COMMAND</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[ -e FILE ] &amp;&amp; [ -r FILE]</p><p>&emsp;&emsp;&emsp;&emsp;第二种方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&amp;&amp;：EXPRESSION1 -a EXPRESSION2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;||：EXPRESSION1 -o EXPRESSION2</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;!EXPRESSION</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;注意这种方式必须使用测试命令进行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[ -z “$hostName” ] || [ “$hostName”==”localhost.localdomain” ]也可以用第二种方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[ -z “$hostName” -o “$hostName”==”localhost.localdomain” ]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab</p><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第6集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;egrep、bash环境配置及脚本、vim编辑器&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第5集</title>
    <link href="https://zhangdashuo.github.io/2018/07/27/redhat05/"/>
    <id>https://zhangdashuo.github.io/2018/07/27/redhat05/</id>
    <published>2018-07-27T06:46:18.000Z</published>
    <updated>2018-07-29T01:48:26.982Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第5集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>shell编程初步及正则表达式<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="bash基础及shell编程初步"><a href="#bash基础及shell编程初步" class="headerlink" title="bash基础及shell编程初步"></a>bash基础及shell编程初步</h2><h3 id="bash基础特性回顾"><a href="#bash基础特性回顾" class="headerlink" title="bash基础特性回顾"></a>bash基础特性回顾</h3><p>&emsp;&emsp;命令行展开：~,{}</p><p>&emsp;&emsp;命令别名：alias/unalias</p><p>&emsp;&emsp;命令历史：history</p><p>&emsp;&emsp;命令和路径补全：$PATH</p><p>&emsp;&emsp;glob：*,?,[]</p><p>&emsp;&emsp;快捷键：ctrl+{a,e,u,k,c,l,&lt;–,–&gt;}</p><p>&emsp;&emsp;命令hash：hash</p><h3 id="bash的基础特性（3）"><a href="#bash的基础特性（3）" class="headerlink" title="bash的基础特性（3）"></a>bash的基础特性（3）</h3><p>提供了编程环境</p><p>&emsp;&emsp;程序：由指令加数据组成（这个概念已经提过好多好多次了呜呜）</p><p>&emsp;&emsp;程序编程风格：</p><p>&emsp;&emsp;&emsp;&emsp;过程式：以指令为中心，数据服务于指令</p><p>&emsp;&emsp;&emsp;&emsp;对象式：以数据为中心，指令服务于数据</p><p>&emsp;&emsp;shell程序：提供了编程能力，解释执行，主要是调用当前系统上的可用二进制程序，组织罗列解释执行</p><p>shell脚本：文本文件</p><p>对于shell脚本来说，第一行开头要写#!/bin/bash这样的代码，这个代码就做shebang。shebang的意义在于对于内核来说只能运行二进制文件，脚本文件中都为接近人类语言的代码，所以如果直接提交给内核运行内核是无法识别的。所以当shell脚本提交内核之后发现shebang标志符则会将代码交由shell解释器去执行，让shell解释器将代码解释为二进制程序再提交给内核进行运行，这就是shebnag的意义。通常对于shell脚本文件来说，也有自己的magic number（魔数），内核也可以通过魔数来分析该文件为shell脚本文件。</p><p>运行脚本：</p><p>&emsp;&emsp;1、给予执行权限，通过具体的文件路径指定文件执行</p><p>&emsp;&emsp;2、直接运行解释器，将脚本作为解释器程序的参数运行</p><p>程序中的变量：</p><p>&emsp;&emsp;变量：命名的内存空间</p><p>&emsp;&emsp;数据存储方式：</p><p>&emsp;&emsp;&emsp;&emsp;字符型：</p><p>&emsp;&emsp;&emsp;&emsp;数值型：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;整形</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;浮点型</p><p>&emsp;&emsp;对于shell脚本语言来说，shell为弱类型的编程语言即某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过显性强制转换。同时shell会把所有要存储的数据全部当作字符串来进行，同时shell不支持浮点数，可以看出shell的作用是命令的堆砌，而不是要进行复杂的数值运算的语言。</p><h2 id="grep及正则表达式"><a href="#grep及正则表达式" class="headerlink" title="grep及正则表达式"></a>grep及正则表达式</h2><h3 id="grep："><a href="#grep：" class="headerlink" title="grep："></a>grep：</h3><p>&emsp;&emsp;Linux上文本处理三剑客：</p><p>&emsp;&emsp;&emsp;&emsp;grep：文本过滤工具（基于模式：pattern）</p><p>&emsp;&emsp;&emsp;&emsp;sed：stream editor 文本编辑工具</p><p>&emsp;&emsp;&emsp;&emsp;awk：Linux上的实现gawk，文本报告生成器</p><p>&emsp;&emsp;grep：Global search REgular expression and Print out the line</p><p>&emsp;&emsp;&emsp;&emsp;作用：文本搜索工具，根据用户指定的模式，对目标文本逐行进行匹配检查，并打印匹配到的行</p><p>&emsp;&emsp;&emsp;&emsp;模式：由正则表达式字符及文本字符所编写的过滤条件</p><p>&emsp;&emsp;&emsp;&emsp;REGEXP（正则表达式）：由一类特殊字符及文本字符所编写的模式，其中有些字符不表示字符字面意义，而表示控制或通配的功能。</p><p>&emsp;&emsp;&emsp;&emsp;正则表达式有两类：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;基本的正则表达式：BRE</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;扩展的正则表达式：ERE，可以使用grep -E ，或egrep来实现</p><p>&emsp;&emsp;&emsp;&emsp;正则表达式引擎：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;grep [OPTIONS] PATTERN [FILE…]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–color=auto：对匹配到的文本着色显示</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-v, –invert-match：显示不能被pattern匹配到的行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-i, –ignore-case：忽略字符大小写</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-o, –only-matching：仅显示匹配到的字符串</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-q, –quiet：静默模式，不输出任何信息</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-A #：affter，后#行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-B #：before，前#行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-C #：context，前后各#行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-E ：使用扩展的正则表达式</p><h3 id="基本正则表达式元字符"><a href="#基本正则表达式元字符" class="headerlink" title="基本正则表达式元字符"></a>基本正则表达式元字符</h3><p>&emsp;&emsp;字符匹配：</p><p>&emsp;&emsp;&emsp;&emsp;.：匹配任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;[]：匹配指定范围内的任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;[^]：匹配指定范围外的任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;注意：这里的字符即合和glob的模式是一样的</p><p>&emsp;&emsp;匹配次数（默认工作在贪婪模式下）：用在要指定次数的字符后面，用于指定前面的字符要出现的次数</p><p>&emsp;&emsp;&emsp;&emsp;*：匹配前面的字符任意次</p><p>&emsp;&emsp;&emsp;&emsp;.*：表示任意长度的任意字符</p><p>&emsp;&emsp;&emsp;&emsp;\?：匹配前面的字符0次或1次，即前面的字符可有可无</p><p>&emsp;&emsp;&emsp;&emsp;+：匹配其前面的字符至少1次</p><p>&emsp;&emsp;&emsp;&emsp;{m\}：匹配其前面的字符m次</p><p>&emsp;&emsp;&emsp;&emsp;{m,n\}：匹配其前面的字符至少m次，至多n次</p><p>&emsp;&emsp;&emsp;&emsp;{0,n\}：匹配前面的字符至多n次</p><p>&emsp;&emsp;&emsp;&emsp;{m,\}：匹配前面的字符至少m次</p><p>&emsp;&emsp;位置锚定：</p><p>&emsp;&emsp;&emsp;&emsp;^：行首锚定，用于模式的最左侧</p><p>&emsp;&emsp;&emsp;&emsp;$：行尾锚定，用于模式的最右侧</p><p>&emsp;&emsp;&emsp;&emsp;^PATTERN$：用于模式匹配整行</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;^$：匹配空白行<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;^[[:space:]]*$：匹配只有空白的行</p><p>&emsp;&emsp;&emsp;&emsp;\&lt;或\b：词首锚定，用于单次模式的左侧</p><p>&emsp;&emsp;&emsp;&emsp;>或\b：词尾锚定，用于单次模式的右侧</p><p>&emsp;&emsp;&emsp;&emsp;\&lt;PATTERN>：匹配整个单次</p><p>&emsp;&emsp;分组：\(\)：将一个或多个字符捆绑再一起当作一个整体进行处理</p><p>&emsp;&emsp;&emsp;&emsp;比如：”\(xy\)\+”表示匹配一个或多个xy字符串</p><p>&emsp;&emsp;&emsp;&emsp;后向引用：引用前面的分组括号中的模式所匹配字符（而非模式本身）</p><p>&emsp;&emsp;&emsp;&emsp;注意：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名方式为：\1，\2，\3，…</p><p>&emsp;&emsp;&emsp;&emsp;\1：表示从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符</p><p>&emsp;&emsp;正则表达式举例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ #1、显示/proc/meminfo文件中以大小s开头的行（使用两种方式）</span><br><span class="line">[zhangshuo@localhost ~]$ grep -i "^s" /proc/meminfo </span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SwapTotal:       2097148 kB</span><br><span class="line">SwapFree:        2097148 kB</span><br><span class="line">Shmem:              7304 kB</span><br><span class="line">Slab:              50244 kB</span><br><span class="line">SReclaimable:      23724 kB</span><br><span class="line">SUnreclaim:        26520 kB</span><br><span class="line">[zhangshuo@localhost ~]$ grep "^[Ss]" /proc/meminfo </span><br><span class="line">SwapCached:            0 kB</span><br><span class="line">SwapTotal:       2097148 kB</span><br><span class="line">SwapFree:        2097148 kB</span><br><span class="line">Shmem:              7304 kB</span><br><span class="line">Slab:              50244 kB</span><br><span class="line">SReclaimable:      23724 kB</span><br><span class="line">SUnreclaim:        26520 kB</span><br><span class="line">[zhangshuo@localhost ~]$ #2、显示/etc/passwd文件中不以/bin/bash结尾的行</span><br><span class="line">[zhangshuo@localhost ~]$ grep -v "/bin/bash$" /etc/passwd</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">[zhangshuo@localhost ~]$ #3、显示/etc/passwd文件中ID号最大的用户的用户名</span><br><span class="line">[zhangshuo@localhost ~]$ sort -n -t : -k 3 /etc/passwd | tail -1 | cut -d : -f 1</span><br><span class="line">nfsnobody</span><br><span class="line">[zhangshuo@localhost ~]$ #4、如果用户root存在，显示其默认的shell程序</span><br><span class="line">[zhangshuo@localhost ~]$ id root &amp;&gt; /dev/null &amp;&amp; grep "^\&lt;root\&gt;" /etc/passwd </span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">[zhangshuo@localhost ~]$ id root &amp;&gt; /dev/null &amp;&amp; grep "^\&lt;root\&gt;" /etc/passwd | cut -d : -f 7</span><br><span class="line">/bin/bash</span><br><span class="line">[zhangshuo@localhost ~]$ #5、找出/etc/passwd中的两位或三位数</span><br><span class="line">[zhangshuo@localhost ~]$ grep "\&lt;[0-9]\&#123;2,3\&#125;\&gt;" /etc/passwd</span><br><span class="line">mail:x:8:12:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line">operator:x:11:0:operator:/root:/sbin/nologin</span><br><span class="line">games:x:12:100:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:14:50:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:99:99:Nobody:/:/sbin/nologin</span><br><span class="line">[zhangshuo@localhost ~]$ #6、显示/etc/grub2.cfg文件中，至少以一个空白字符开头的且后面存在非空白字符的行</span><br><span class="line">[root@localhost ~]# grep "^[[:space:]]\+[^[:space:]]" /etc/grub2.cfg</span><br><span class="line">  load_env</span><br><span class="line">   set default="$&#123;next_entry&#125;"</span><br><span class="line">   set next_entry=</span><br><span class="line">   save_env next_entry</span><br><span class="line">   set boot_once=true</span><br><span class="line">   set default="$&#123;saved_entry&#125;"</span><br><span class="line">  menuentry_id_option="--id"</span><br><span class="line">  menuentry_id_option=""</span><br><span class="line">[zhangshuo@localhost ~]$ #7、找出“netstat -tan”命令的结果中以“LISTEN”后跟0个1个或多个空白字符结尾的行</span><br><span class="line">[zhangshuo@localhost ~]$ netstat -tan | grep "LISTEN[[:space:]]*$"</span><br><span class="line">tcp        0      0 192.168.122.1:53        0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp6       0      0 :::21                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 :::22                   :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:631                 :::*                    LISTEN     </span><br><span class="line">tcp6       0      0 ::1:25                  :::*                    LISTEN     </span><br><span class="line">[zhangshuo@localhost ~]$ #8、添加用户bash，testbash，basher以及nologin（其shell为/sbin/nologin）而后找出/etc/passwd文件中用户名同shell名的行</span><br><span class="line">[zhangshuo@localhost ~]$ #首先找用户名</span><br><span class="line">[zhangshuo@localhost ~]$ grep "^[[:alnum:]]\+\&gt;" /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">[zhangshuo@localhost ~]$ #再找用户名同shell名的行</span><br><span class="line">[zhangshuo@localhost ~]$ grep "^\([[:alnum:]]\+\&gt;\).*\1$" /etc/passwd</span><br><span class="line">sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:7:0:halt:/sbin:/sbin/halt</span><br></pre></td></tr></table></figure><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第5集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;shell编程初步及正则表达式&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第4集</title>
    <link href="https://zhangdashuo.github.io/2018/07/21/redhat04/"/>
    <id>https://zhangdashuo.github.io/2018/07/21/redhat04/</id>
    <published>2018-07-21T02:49:42.000Z</published>
    <updated>2018-07-27T13:32:45.419Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第4集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>Linux的文件管理，管道，用户组管理，用户权限管理<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="文件管理，命令别名和glob"><a href="#文件管理，命令别名和glob" class="headerlink" title="文件管理，命令别名和glob"></a>文件管理，命令别名和glob</h2><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>相关命令：cp，mv，rm</p><p>复制命令：cp</p><p>&emsp;&emsp;cp [OPTION]… [-T] SOURCE DEST</p><p>&emsp;&emsp;&emsp;&emsp;cp [OPTION]… SOURCE… DIRECTORY</p><p>&emsp;&emsp;&emsp;&emsp;cp [OPTION]… -t DIRECTORY SOURCE…</p><p>&emsp;&emsp;cp SRC DEST ：SRC是文件</p><p>&emsp;&emsp;&emsp;&emsp;如果目标不存在：新建DEST，并将SRC中内容填充至DEST中。</p><p>&emsp;&emsp;&emsp;&emsp;如果目标存在：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;1、如果DEST是文件：将SRC中的内容覆盖至DEST中，此时建议为cp命令使用-i选项。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2、如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填充至新文件中。</p><p>&emsp;&emsp;cp SRC DEST ：SRC…为多个文件</p><p>&emsp;&emsp;&emsp;&emsp;DEST必须存在且要为目录，其它情况均会报错。</p><p>&emsp;&emsp;cp SRC DEST ：SRC是目录</p><p>&emsp;&emsp;&emsp;&emsp;对于源为目录时，要使用：-r选项进行递归复制。</p><p>&emsp;&emsp;&emsp;&emsp;1、如果DEST不存在，则创建指定目录，复制SRC目录中所有文件至DEST中。</p><p>&emsp;&emsp;&emsp;&emsp;2、如果DEST存在，如果DEST是文件，则报错。如果DEST是目录则将所有文件复制至DEST中。</p><p>&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;-i, –interactive：交互式提醒。</p><p>&emsp;&emsp;&emsp;&emsp;-R, -r, –recursive：递归复制目录及内部的所有数据。</p><p>&emsp;&emsp;&emsp;&emsp;-a, –archive（归档）：该选项主要用来做备份。same as -dR –preserve=all。</p><p>&emsp;&emsp;&emsp;&emsp;–preserve[=ATTR_LIST]：保持某些属性</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;default: mode(权限),ownership(属主,属组),timestamps(时间戳)。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;additional attributes: context(安全上下文), links(符号链接), xattr(扩展属性), all(所有属性)。</p><p>&emsp;&emsp;&emsp;&emsp;-d     same as –no-dereference –preserve=links ：不追踪符号链接文件。</p><p>&emsp;&emsp;&emsp;&emsp;-p     same as –preserve=mode,ownership,timestamps ：保留文件的基本属性。</p><p>&emsp;&emsp;&emsp;&emsp;-v, –verbose：显示详细的过程信息。</p><p>&emsp;&emsp;&emsp;&emsp;-t, –target-directory=DIRECTORY ：源和目标倒过来。</p><p>移动命令：mv 该命令和cp很是类似就不展开了</p><p>&emsp;&emsp;mv [OPTION]… [-T] SOURCE DEST</p><p>&emsp;&emsp;&emsp;&emsp;mv [OPTION]… SOURCE… DIRECTORY</p><p>&emsp;&emsp;&emsp;&emsp;mv [OPTION]… -t DIRECTORY SOURCE…</p><p>&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;-i, –interactive：交互式提醒。</p><p>&emsp;&emsp;&emsp;&emsp;-f, –force：do not prompt before overwriting</p><p>删除命令：rm</p><p>&emsp;&emsp;rm [OPTION]… FILE…</p><p>&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;-i：交互式</p><p>&emsp;&emsp;&emsp;&emsp;-f：强制删除不提醒</p><p>&emsp;&emsp;&emsp;&emsp;-r：递归删除</p><p>&emsp;&emsp;&emsp;&emsp;删除目录时常用：rm -rf DRC</p><h3 id="文本编辑器：nano"><a href="#文本编辑器：nano" class="headerlink" title="文本编辑器：nano"></a>文本编辑器：nano</h3><p>&emsp;&emsp;全屏编辑器，类似windows下的记事本，简单易用，但是效率不高，后面会有vim的描述。</p><h3 id="bash的基础特性（二）"><a href="#bash的基础特性（二）" class="headerlink" title="bash的基础特性（二）"></a>bash的基础特性（二）</h3><p>1、命令别名（alias）</p><p>&emsp;&emsp;通过alias命令实现：</p><p>&emsp;&emsp;&emsp;&emsp;(1)直接运行alias命令可查看当前系统所有定义的别名。</p><p>&emsp;&emsp;&emsp;&emsp;(2)alias NAME=’VALUE’ 定义别名NAME，其相当于执行命令VALUE</p><p>&emsp;&emsp;注意：在命令行中定义的别名仅对当前shell进程有效，如果想永久有效，要定义在配置文件中：</p><p>&emsp;&emsp;配置文件有两种：</p><p>&emsp;&emsp;&emsp;&emsp;【1】仅对当前用户有效：~./bashrc</p><p>&emsp;&emsp;&emsp;&emsp;【2】所有用户都有效：/etc/bashrc</p><p>&emsp;&emsp;注意：编辑配置文件给出的新配置不会立即生效，如果要生效需要让bash重读配置文件。</p><p>&emsp;&emsp;bash重新读去配置文件的方法：</p><p>&emsp;&emsp;&emsp;&emsp;source /path/to/config-file</p><p>&emsp;&emsp;&emsp;&emsp;. /path/to/config-file</p><p>&emsp;&emsp;撤销定义的命令别名：unalias</p><p>&emsp;&emsp;&emsp;&emsp;unalias [-a] name [name …]：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-a：取消所有别名。</p><p>&emsp;&emsp;注意：如果别名同原命令的名称，则如果要执行原命令可使用”\ command”。</p><p>2、glob（globbing）</p><p>&emsp;&emsp;bash中用于实现文件名通配的机制</p><p>&emsp;&emsp;glob中的通配符：*,?,[]</p><p>&emsp;&emsp;(1)*：表示任意长度的任意字符。</p><p>&emsp;&emsp;&emsp;&emsp;比如：a*b：aab，ab，a123b都可以被a*b匹配到</p><p>&emsp;&emsp;(2)?：表示任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;比如：a?b：aab，abb</p><p>&emsp;&emsp;(3)[]：表示匹配制定范围内的任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;比如：[abc],[0-9],[a-z],[A-Z]等。</p><p>&emsp;&emsp;(4)[^]：表示匹配指定范围外的任意单个字符</p><p>&emsp;&emsp;&emsp;&emsp;比如： [ ^0-9]:除数字    [^0-9a-z]:只保留特殊字符</p><p>&emsp;&emsp;专用字符集合如下：</p><p>&emsp;&emsp;&emsp;&emsp;[:alnum:]：任意数字或字母    [:alpha:]：任意大小写字母    [:blank:]：空白</p><p>&emsp;&emsp;&emsp;&emsp;[:cntrl:]：控制字符            [:digit:]：任意数字相当于0-9    [:graph:]：图片</p><p>&emsp;&emsp;&emsp;&emsp;[:lower:]：任意小写字母        [:print:]：打印字符            [:punct:]：标点符号</p><p>&emsp;&emsp;&emsp;&emsp;[:space:]：空格            [:upper:]：任意大写字母        [:xdigit:]：16进制数字</p><p>&emsp;&emsp;glob的应用举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost test]$ #显示/tmp/test目录下所有以L开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录</span><br><span class="line">[zhangshuo@localhost test]$ pwd</span><br><span class="line">/tmp/test</span><br><span class="line">[zhangshuo@localhost test]$ ls -ld  L*[0-9]*[[:lower:]]</span><br><span class="line">-rw-rw-r--. 1 zhangshuo zhangshuo 0 Jul 27 13:28 Ljj778l</span><br><span class="line">drwxrwxr-x. 2 zhangshuo zhangshuo 6 Jul 27 13:29 Ljkjkj8lll</span><br><span class="line">[zhangshuo@localhost test]$</span><br><span class="line">[zhangshuo@localhost test]$ #显示/tpm/test目录下，以任意一位数字开口，且以非数字结尾的文件或目录</span><br><span class="line">[zhangshuo@localhost test]$ ls</span><br><span class="line">8jkjkj6  8kjkkj  Ljj778l  Ljkjkj  Ljkjkj8lll</span><br><span class="line">[zhangshuo@localhost test]$ ls -ld [0-9]*[^0-9]</span><br><span class="line">-rw-rw-r--. 1 zhangshuo zhangshuo 0 Jul 27 13:34 8kjkkj</span><br><span class="line">[zhangshuo@localhost test]$ #显示/tmp/test目录下以非字母开头，后面跟了一个字母的文件或目录</span><br><span class="line">[zhangshuo@localhost test]$ ls -ld [^[:alpha:]][[:alpha:]]*</span><br><span class="line">-rw-rw-r--. 1 zhangshuo zhangshuo 0 Jul 27 13:35 8jkjkj6</span><br><span class="line">-rw-rw-r--. 1 zhangshuo zhangshuo 0 Jul 27 13:34 8kjkkj</span><br></pre></td></tr></table></figure><p>3、bash的快捷键</p><p>&emsp;&emsp;Ctrl+l：清屏，相当于clear命令。</p><p>&emsp;&emsp;Ctrl+a：跳转到命令开始处，即命令行行首。</p><p>&emsp;&emsp;Ctrl+e：跳转至命令结尾处。</p><p>&emsp;&emsp;Ctrl+c：取消命令的执行。</p><p>&emsp;&emsp;Ctrl+u：删除命令行首至光标所在处的所有内容。</p><p>&emsp;&emsp;Ctrl+k：删除光标所在处至命令行尾部的所有内容。</p><p>&emsp;&emsp;Ctrl+左右箭头：一次跳一个单词。</p><h2 id="IO重定向、管道及文本处理工具"><a href="#IO重定向、管道及文本处理工具" class="headerlink" title="IO重定向、管道及文本处理工具"></a>IO重定向、管道及文本处理工具</h2><h3 id="IO重定向"><a href="#IO重定向" class="headerlink" title="IO重定向"></a>IO重定向</h3><p>计算机中的程序是由指令加数据组成的。程序在运行时总要读取数据，和计算的数据结果也要进行输出。读取数据的来源可以是键盘，文件，网络等。输出结果的方式也很多比如打印机，显示器，以文件形式输出等，但对于输入来说从键盘读去数据，和输出至屏幕的方式无疑是最好的交互方式和最廉价的数据读去和输入方式。</p><p>上面提过Linux的哲学思想中有一条就是一切皆文件，在文件系统描述那一章也提过Linux的文件类型等，比如-，b，l，c，d，p，s等，有不同的文件类型，对于文件类型我们可以使用file命令进行查看。Linux下对于每个打开的文件都有自己的描述符，这里叫做fd（file descriptor）。所以对于输出设备输入设备等也都是以文件形式描述，所以这些设备也应该有自己的描述符。</p><p>标准输入：keyborad，描述符用0表示。比如cat命令就默认从键盘读去数据。</p><p>标准输出：monitor，描述符用1表示。</p><p>标准错误输出：monitor，描述符用2表示。（犯错的人一般都比较2，你懂的）</p><p>IO重定向的作用：改变标准输入输出位置，对输入输出重新定义。</p><p>输出重定向：COMMAND &gt; NEW_POS，COMMAND &gt; NEW_POS。</p><p>&emsp;&emsp;\ &gt;：覆盖重定向，目标文件中的原有内容会被清除。</p><p>&emsp;&emsp;>&gt;：追加重定向，新内容会追加至目标文件尾部。</p><p>&emsp;&emsp;对于覆盖重定向的操作是比较危险的，因为这样很可能造成重大的事故或重要数据的丢失。比如 echo “hello world” &gt; /dev/sda 这个操作是在/dev/sda设备的开头处写入hello world并清除整个设备。这个操作的结果就是整个磁盘的分区表没有了。所以整个磁盘数据也就丢失了。所以Linux下可以通过某些设置来保护对于有数据的文件不会被覆盖重定向。设置的方式如下。</p><p>&emsp;&emsp;#<code>set -C</code>：禁止将内容覆盖输出至已有文件中。</p><p>&emsp;&emsp;&emsp;&emsp;当该功能设置时，如果你很确定我确实是要执行覆盖重定向，可以使用 &gt;| 即可。</p><p>&emsp;&emsp;#<code>set +C</code>：关闭该功能。    </p><p>&emsp;&emsp;2&gt;：覆盖重定向错误输出数据流。</p><p>&emsp;&emsp;2&gt;&gt;：追加重定向错误输出数据流。</p><p>&emsp;&emsp;对于一个操作，同时对标准输出和错误输出进行重定向到不同的位置时可以使用：</p><p>&emsp;&emsp;&emsp;&emsp;COMMAND &gt; /path/to/file.out 2&gt; /path/to/error.out</p><p>&emsp;&emsp;合并标准输出和错误输出为同一个数据流进行重定向：</p><p>&emsp;&emsp;&emsp;&emsp;&amp;&gt;：覆盖重定向双输出流至同一个文件。</p><p>&emsp;&emsp;&emsp;&emsp;&amp;&gt;&gt;：追加重定向双数据流至同一个文件。</p><p>&emsp;&emsp;&emsp;&emsp;COMMAND &gt; /path/to/file.out 2&gt; &amp;1</p><p>&emsp;&emsp;&emsp;&emsp;COMMAND &gt;&gt; /path/to/file.out 2&gt;&gt; &amp;1</p><p>输入重定向：&lt;</p><p>&emsp;&emsp;tr命令：转换或删除字符</p><p>&emsp;&emsp;&emsp;&emsp;tr [OPTION]… SET1 [SET2]</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-d<strong>, </strong>–delete：删除指定字符</p><p>&emsp;&emsp;&emsp;&emsp;对于tr命令来说，是直接从标准输入读去字符然后按参数进行转换的比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ tr abc ABC</span><br><span class="line">ni hao ya ha ha ha</span><br><span class="line">ni hAo yA hA hA hA</span><br><span class="line">[zhangshuo@localhost ~]$ tr -d abc</span><br><span class="line">how are you</span><br><span class="line">how re you</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;对tr命令进行输入重定向，即从文件读取数据进行处理如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ tr [a-z] [A-Z] &lt; /etc/passwd | tail -2</span><br><span class="line">VBOXADD:X:987:1::/VAR/RUN/VBOXADD:/BIN/FALSE</span><br><span class="line">GLUSTER:X:986:980:GLUSTERFS DAEMONS:/VAR/RUN/GLUSTER:/SBIN/NOLOGIN</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Here documentation：&lt;&lt; 该符号不是表示追加输入重定向，而是表示在此处生成文档。</p><p>&emsp;&emsp;对于cat命令默认为标准输入读去数据，这里使用cat命令进行文档生成和保存文件，用法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost test]$ pwd</span><br><span class="line">/tmp/test</span><br><span class="line">[zhangshuo@localhost test]$ cat &gt;&gt; ./cattest.txt &lt;&lt;EOF</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> how are you</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> how old are you</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> EOF</span></span><br><span class="line">[zhangshuo@localhost test]$ cat cattest.txt </span><br><span class="line">how are you</span><br><span class="line">how old are you</span><br><span class="line">[zhangshuo@localhost test]$</span><br></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>对于管道又体现了Linux的哲学思想之一，那就是可实现组合小程序来完成复杂任务。</p><p>用法：COMMAND 1| COMMAND 2 | COMMAND 3 | …：前一个命令的输出，作为后一个命令的输入</p><p>Note：最后一个命令会在当前shell进程的子进程中执行，比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ echo "$PATH" | tr [a-z] [A-Z] | tr -d 'U'</span><br><span class="line">/HOME/ZHANGSHO/.NPM-GLOBAL/BIN:/SR/LOCAL/BIN:/SR/BIN:/SR/LOCAL/SBIN:/SR/SBIN:/SR/LOCAL/NODE/BIN:/HOME/ZHANGSHO/.LOCAL/BIN:/HOME/ZHANGSHO/BIN</span><br><span class="line">[zhangshuo@localhost ~]$ echo $PATH</span><br><span class="line">/home/zhangshuo/.npm-global/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/node/bin:/home/zhangshuo/.local/bin:/home/zhangshuo/bin</span><br></pre></td></tr></table></figure><p>上面说到的重定向的方法中，都可以将输出流定义到其它位置，而有时我们又需要一边在屏幕上的输出数据又需要将数据保存至文件便于后期分析，此时管道就可以完美解决问题。</p><p>tee命令：</p><p>&emsp;&emsp;tee [OPTION]… [FILE]… </p><p>用法举例：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost test]$ pwd</span><br><span class="line">/tmp/test</span><br><span class="line">[zhangshuo@localhost test]$ tee tee.out</span><br><span class="line">first line:</span><br><span class="line">first line:</span><br><span class="line">second line:</span><br><span class="line">second line:</span><br><span class="line">^C</span><br><span class="line">[zhangshuo@localhost test]$ cat tee.out </span><br><span class="line">first line:</span><br><span class="line">second line:</span><br><span class="line">[zhangshuo@localhost test]$ echo $PATH | tee tee.path.out</span><br><span class="line">/home/zhangshuo/.npm-global/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/node/bin:/home/zhangshuo/.local/bin:/home/zhangshuo/bin</span><br><span class="line">[zhangshuo@localhost test]$ cat tee.path.out </span><br><span class="line">/home/zhangshuo/.npm-global/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/node/bin:/home/zhangshuo/.local/bin:/home/zhangshuo/bin</span><br></pre></td></tr></table></figure><h3 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h3><p>命令：wc，cut，sort，uniq</p><p>wc命令：统计文件的行数，单词数，和字符数等信息</p><p>&emsp;&emsp;wc [OPTION]… [FILE]… </p><p>&emsp;&emsp;&emsp;&emsp;-l<strong>, </strong>–lines：行数</p><p>&emsp;&emsp;&emsp;&emsp;-w<strong>, </strong>–words：单词数</p><p>&emsp;&emsp;&emsp;&emsp;-c<strong>, </strong>–bytes：字节数</p><p>cut命令：remove sections from each line of files（感觉还是英文解释更地道，我翻译过来是对文件中每行中部分内容移动）</p><p>&emsp;&emsp;cut OPTION… [FILE]… </p><p>&emsp;&emsp;&emsp;&emsp;-d<strong>, </strong>–delimiter=DELIMITER：指定字段分隔符</p><p>&emsp;&emsp;&emsp;&emsp;-f<strong>, </strong>–fields=LIST：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#：第#个字段</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#,#：离散的多个字段，例如：1,7,9,</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;#-#：连续的多个字段</p><p>&emsp;&emsp;&emsp;&emsp;–output-delimiter=STRING：输出时将分隔符替换为STRING</p><p>sort命令：</p><p>&emsp;&emsp;sort [OPTION]… [FILE]…</p><p>&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;-f, –ignore-case：忽略字符大小写</p><p>&emsp;&emsp;&emsp;&emsp;-r, –reverse：逆序排序</p><p>&emsp;&emsp;&emsp;&emsp;-t, –field-separator=SEP：指明字段分割符</p><p>&emsp;&emsp;&emsp;&emsp;-k, –key=KEYDEF：以指定字段为标准排序</p><p>&emsp;&emsp;&emsp;&emsp;-n, –numeric-sort：以数值大小写进行排序</p><p>&emsp;&emsp;&emsp;&emsp;-u, –unique：排序后去重，相同的内容只显示一次</p><p>uniq命令：</p><p>&emsp;&emsp;uniq [OPTION]… [INPUT [OUTPUT]]</p><p>&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;-c, –count：显示每行重复出现的次数</p><p>&emsp;&emsp;&emsp;&emsp;-d, –repeated：仅显示重复过的行</p><p>&emsp;&emsp;&emsp;&emsp;-u, –unique：仅显示未重复的行</p><p>举例如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ #取出/etc/passwd文件的第6至第10行，并将这些信息按第3个字段的数值大小进行排序，最后仅显示各自的第一个字段</span><br><span class="line">[zhangshuo@localhost ~]$ head -10 /etc/passwd | tail -4 | sort -n -t : -k 3 | cut -d : -f 1</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br></pre></td></tr></table></figure><h2 id="用户及组管理"><a href="#用户及组管理" class="headerlink" title="用户及组管理"></a>用户及组管理</h2><p>计算机的资源是非常宝贵的，通常对于主机来说应该是只允许那些有那能力或是有需要的人进行登陆，而且Linux就是一个多用户，多任务的操作系统，所以需要对登陆用户的身份进行验证，验证通过之后方可准许登陆系统。这就是Linux的用户认证机制。用户认证机制的主要作用是为了实现将有限的计算机资源分配给特定的人。</p><p>通常对于用户需要进行如下认证：</p><p>&emsp;&emsp;1、Authentication：认证（目的是是否允许登陆系统）</p><p>&emsp;&emsp;2、Authorization：授权（是否允许用户有管理员权限）</p><p>&emsp;&emsp;3、Accoating：审计（对于管理员来说能力越大就责任越大，所以对于管理员的权限是需要审计的）</p><p>Linux下的用户：</p><p>&emsp;&emsp;管理员：root，UID：0，命令提示符：#</p><p>&emsp;&emsp;普通用户：UID：1-65535，命令提示符：$</p><p>&emsp;&emsp;&emsp;&emsp;系统用户：UID：1-999。作用：守护进程获取资源进行权限分配</p><p>&emsp;&emsp;&emsp;&emsp;登陆用户：UID：1000+</p><p>Linux下的组：</p><p>&emsp;&emsp;组的作用是实现授权某类用户具有权限</p><p>&emsp;&emsp;管理员组：root，GID：0</p><p>&emsp;&emsp;普通组：GID:1-65535</p><p>&emsp;&emsp;&emsp;&emsp;管理员组：GID：1-999</p><p>&emsp;&emsp;&emsp;&emsp;普通用户组：GID：1000+</p><p>Linux的安全上下文：</p><p>&emsp;&emsp;计算机上运行中的程序叫做进程（process），进程是以发起者的身份运行程序的，进程所能够访问的所有资源的权限取决于进程的发起者的身份。就是Linux下的安全上下文。</p><p>Linux用户组的类别：</p><p>&emsp;&emsp;用户的基本组（主组）：在用户创建文件时，默认将以主组的身份进行创建。</p><p>&emsp;&emsp;用户的私有组：组名同用户名，且仅包含该用户的用户的私有组</p><p>&emsp;&emsp;用户的附加组：用户额外加入的组</p><p>Linux用户和组相关的配置文件</p><p>&emsp;&emsp;/etc/passwd：保存用户及其属性信息</p><p>&emsp;&emsp;/etc/group：组及其属性信息</p><p>&emsp;&emsp;/etc/shadow：用户密码及其相关属性</p><p>&emsp;&emsp;/etc/gshadow：组密码及其相关属性</p><p>&emsp;&emsp;/etc/passwd：</p><p>&emsp;&emsp;&emsp;&emsp;name：password：UID：GID：GECOS：Directory：shell</p><p>&emsp;&emsp;&emsp;&emsp;用户：密码占位符x：UID：GID：用户的完整信息：用户的家目录：用户的默认shell</p><p>&emsp;&emsp;/etc/group：</p><p>&emsp;&emsp;&emsp;&emsp;group_name：password：GID：user_list</p><p>&emsp;&emsp;&emsp;&emsp;组名：组密码：GID：以当前组为附加组的用户列表（以逗号为分隔符）</p><p>&emsp;&emsp;/etc/shadow：</p><p>&emsp;&emsp;&emsp;&emsp;该文件是由：进行分割的9段组成</p><p>&emsp;&emsp;&emsp;&emsp;用户名：加密了的密码：最近一次更改密码的日期：密码的最小使用期限：密码的最大使用期限：密码的警告时间：密码禁用期：账户过期日期：保留字段</p><p>&emsp;&emsp;单向加密：这里的密码加密机制是使用单向加密算法进行加密的，即提取数据指纹，常用于数据完整性校验。</p><p>&emsp;&emsp;1、雪崩效应：初始条件的微小改变将会引起结果的巨大改变</p><p>&emsp;&emsp;2、定长输出：</p><p>&emsp;&emsp;&emsp;&emsp;md5：message digest 128位定长输出</p><p>&emsp;&emsp;&emsp;&emsp;sha1：secure hash algorithm 160位定长输出</p><p>&emsp;&emsp;&emsp;&emsp;sha224：224位  sha256：256位  sha384：384位  sha512：512位</p><p>&emsp;&emsp;密码的复杂性策略</p><p>&emsp;&emsp;&emsp;&emsp;1、使用数字，大写字码，小写字母及特殊字符中至少3种</p><p>&emsp;&emsp;&emsp;&emsp;2、密码的长度要足够长</p><p>&emsp;&emsp;&emsp;&emsp;3、使用随机密码</p><p>&emsp;&emsp;&emsp;&emsp;4、定期更换：不要使用最近曾经使用过的密码</p><h2 id="用户管理及权限管理"><a href="#用户管理及权限管理" class="headerlink" title="用户管理及权限管理"></a>用户管理及权限管理</h2><h3 id="用户创建命令：useradd"><a href="#用户创建命令：useradd" class="headerlink" title="用户创建命令：useradd"></a>用户创建命令：useradd</h3><p>&emsp;&emsp;useradd [options] LOGIN</p><p>&emsp;&emsp;&emsp;&emsp;-u, –uid UID：指定用户的UID。范围为[UID_MIN,UID_MAX]，该区间定义在/etc/login.defs</p><p>&emsp;&emsp;&emsp;&emsp;-g, –gid GROUP：指定用户的基本组，可以为组名，也可以为GID，但是如果要指定组时，该组必须事先存在</p><p>&emsp;&emsp;&emsp;&emsp;-c, –comment COMMENT：用户的注释信息</p><p>&emsp;&emsp;&emsp;&emsp;-d, –home-dir HOME_DIR：指定用户的家目录位置</p><p>&emsp;&emsp;&emsp;&emsp;-s, –shell SHELL：指定用户的默认shell程序，可用列表在/etc/shells文件中，默认定义在/etc/default/useradd文件中</p><p>&emsp;&emsp;&emsp;&emsp;-r, –system：创建系统用户</p><p>&emsp;&emsp;&emsp;&emsp;-G, –groups GROUP1[,GROUP2,…[,GROUPN]]]：为用户指定附加组，在此之前组必须事先存在</p><p>&emsp;&emsp;useradd -D [options] ：修改添加用户时的默认属性</p><p>&emsp;&emsp;&emsp;&emsp;-s：shell</p><h3 id="组创建命令：groupadd"><a href="#组创建命令：groupadd" class="headerlink" title="组创建命令：groupadd"></a>组创建命令：groupadd</h3><p>&emsp;&emsp;groupadd [options] group</p><p>&emsp;&emsp;&emsp;&emsp;-g, –gid GID：指定组的GID号，同样GID：[GID_MIN,GID_MAX]</p><p>&emsp;&emsp;&emsp;&emsp;-r, –system：创建系统组</p><h3 id="查看用户相关的ID信息：id"><a href="#查看用户相关的ID信息：id" class="headerlink" title="查看用户相关的ID信息：id"></a>查看用户相关的ID信息：id</h3><p>&emsp;&emsp;id [OPTION]… [USER]</p><p>&emsp;&emsp;&emsp;&emsp;-u, –user：显示用户的UID</p><p>&emsp;&emsp;&emsp;&emsp;-g, –group：显示用户的GID</p><p>&emsp;&emsp;&emsp;&emsp;-G, –groups：显示用户的附加组</p><h3 id="切换用户或以其他用户身份执行命令：su"><a href="#切换用户或以其他用户身份执行命令：su" class="headerlink" title="切换用户或以其他用户身份执行命令：su"></a>切换用户或以其他用户身份执行命令：su</h3><p>&emsp;&emsp;su [options…][-][user [args…]]</p><p>&emsp;&emsp;&emsp;&emsp;切换用户的方式：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;su USERNAME：非登陆式切换，即不会读取目标用户的配置文件</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;su - USERNAME：登陆式切换，会读取目标用户的配置文件，完全切换</p><p>&emsp;&emsp;&emsp;&emsp;注意：root su至其他用户无需密码，非root用户切换时需要密码</p><p>&emsp;&emsp;&emsp;&emsp;以其他用户执行命令：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;su [-] USERNAME -c ‘COMMAND’：不切换用户，仅以该用户身份运行命令</p><h3 id="用户属性修改：usermod"><a href="#用户属性修改：usermod" class="headerlink" title="用户属性修改：usermod"></a>用户属性修改：usermod</h3><p>&emsp;&emsp;usermod [options] LOGIN</p><p>&emsp;&emsp;&emsp;&emsp;-u, –uid UID：新的UID</p><p>&emsp;&emsp;&emsp;&emsp;-g, –gid GROUP：新的GID，即基本组ID</p><p>&emsp;&emsp;&emsp;&emsp;-G, –groups GROUP1[,GROUP2,…[,GROUPN]]]：新附加组，原来的附加组会被覆盖，若保留原有，则要同时使用-a选项表示增加</p><p>&emsp;&emsp;&emsp;&emsp;-s, –shell SHELL：新的默认shell</p><p>&emsp;&emsp;&emsp;&emsp;-c, –comment COMMENT：新的注释信息</p><p>&emsp;&emsp;&emsp;&emsp;-d, –home HOME_DIR：新的家目录，原有家目录中的文件不会同时移动至新的家目录下，若要移动，则同时使用-m选项</p><p>&emsp;&emsp;&emsp;&emsp;-l, –login NEW_LOGIN：新的用户名</p><p>&emsp;&emsp;&emsp;&emsp;-L, –lock：锁定用户</p><p>&emsp;&emsp;&emsp;&emsp;-U, –unlock：解锁用户</p><h3 id="给用户添加密码：passwd"><a href="#给用户添加密码：passwd" class="headerlink" title="给用户添加密码：passwd"></a>给用户添加密码：passwd</h3><p>&emsp;&emsp;passwd USERNAME：修改指定用户的密码，仅root用户有权限</p><p>&emsp;&emsp;passwd：修改自己的密码</p><p>&emsp;&emsp;&emsp;&emsp;常用选项：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-l, –lock：锁定指定用户</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-u, –unlock：解锁指定用户</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-n, –minimum DAYS：指定密码最短使用期限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-x, –maximum DAYS：指定密码最长使用期限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-w, –warning DAYS：提前多少天开始警告用户修改密码</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-i, –inactive DAYS：非活动期限</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;–stdin：从标准输入接收用户密码</p><p>&emsp;&emsp;&emsp;&emsp;echo “PASSWORD” | passwd –stdin USERNAME</p><h3 id="删除用户：userdel"><a href="#删除用户：userdel" class="headerlink" title="删除用户：userdel"></a>删除用户：userdel</h3><p>&emsp;&emsp;userdel [options] LOGIN</p><p>&emsp;&emsp;&emsp;&emsp;-r, –remove：删除用户家目录</p><h3 id="组属性修改：groupmod"><a href="#组属性修改：groupmod" class="headerlink" title="组属性修改：groupmod"></a>组属性修改：groupmod</h3><p>&emsp;&emsp;groupmod [options] GROUP</p><p>&emsp;&emsp;&emsp;&emsp;-n, –new-name NEW_GROUP：新的组名</p><p>&emsp;&emsp;&emsp;&emsp;-g, –gid GID：重新定义组的GID</p><h3 id="组删除：groupdel"><a href="#组删除：groupdel" class="headerlink" title="组删除：groupdel"></a>组删除：groupdel</h3><p>&emsp;&emsp;groupdel [options] GROUP</p><h3 id="组密码管理：gpasswd"><a href="#组密码管理：gpasswd" class="headerlink" title="组密码管理：gpasswd"></a>组密码管理：gpasswd</h3><p>&emsp;&emsp;gpasswd [option] group</p><p>&emsp;&emsp;&emsp;&emsp;-a, –add user：将user添加至指定组中</p><p>&emsp;&emsp;&emsp;&emsp;-d, –delete user：删除用户user的附加组</p><p>&emsp;&emsp;&emsp;&emsp;-A, –administrators user1，user2…：设置有管理权限的用户列表</p><p>&emsp;&emsp;newgrp命令：临时切换基本组</p><p>&emsp;&emsp;&emsp;&emsp;如果用户本不属于此组，则需要组密码。</p><h3 id="检查用户完整性：pwck"><a href="#检查用户完整性：pwck" class="headerlink" title="检查用户完整性：pwck"></a>检查用户完整性：pwck</h3><h3 id="修改用户属性"><a href="#修改用户属性" class="headerlink" title="修改用户属性"></a>修改用户属性</h3><p>&emsp;&emsp;chage [options] LOGIN</p><p>&emsp;&emsp;&emsp;&emsp;-d, –lastday LAST_DAY：最近一次的修改时间</p><p>&emsp;&emsp;&emsp;&emsp;-E, –expiredate EXPIRE_DATE：过期时间</p><p>&emsp;&emsp;&emsp;&emsp;-I, –inactive INACTIVE：非活动时间</p><p>&emsp;&emsp;&emsp;&emsp;-m, –mindays MIN_DAYS：密码最短使用时间</p><p>&emsp;&emsp;&emsp;&emsp;-M, –maxdays MAX_DAYS：密码最长使用时间</p><p>&emsp;&emsp;&emsp;&emsp;-W, –warndays WARN_DAYS：警告时间</p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>&emsp;&emsp;chfn：修改用户的注释信息。chsh：更改shell。finger：显示用户的信息。</p><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>文件的权限主要针对三类对象进行定义：</p><p>&emsp;&emsp;owner：属主，用u表示</p><p>&emsp;&emsp;group：属组，用g表示</p><p>&emsp;&emsp;other：其它，用o表示</p><p>同时每个文件对每类访问者都定义了三种权限：</p><p>&emsp;&emsp;r：可读</p><p>&emsp;&emsp;w：可写</p><p>&emsp;&emsp;x：可执行的</p><p>&emsp;&emsp;对于文件来说：</p><p>&emsp;&emsp;&emsp;&emsp;r：表示可以使用文件查看类工具获取其内容</p><p>&emsp;&emsp;&emsp;&emsp;w：可修改其内容，即可对文件进行编辑</p><p>&emsp;&emsp;&emsp;&emsp;x：可以把该文件提请给内核执行并启动为一个进程</p><p>&emsp;&emsp;对于目录来说：</p><p>&emsp;&emsp;&emsp;&emsp;r：表示可以使用ls来查看此目录中文件列表</p><p>&emsp;&emsp;&emsp;&emsp;w：可在此目录中创建文件，也可以删除此目录中的文件</p><p>&emsp;&emsp;&emsp;&emsp;注意：如果某用户对某目录有w权限，但对该目录下某个文件没有w权限，该用户是可以将没有w权限的文件进行删除的</p><p>&emsp;&emsp;&emsp;&emsp;x：可以使用ls -l查看此目录文件列表，可以cd进入此目录</p><h3 id="修改文件权限：chmod"><a href="#修改文件权限：chmod" class="headerlink" title="修改文件权限：chmod"></a>修改文件权限：chmod</h3><p>&emsp;&emsp;chmod [OPTION]… OCTAL-MODE FILE…：直接修改某个文件为指定的权限</p><p>&emsp;&emsp;&emsp;&emsp;-R, –recursive：递归修改权限</p><p>&emsp;&emsp;chmod [OPTION]… MODE[,MODE]… FILE…</p><p>&emsp;&emsp;&emsp;&emsp;MODE：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;修改一类用户的所有权限：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;u=rx,g=r,o=</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;修改一类用户某位或某些位权限：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;u+x</p><p>&emsp;&emsp;chmod [OPTION]… –reference=RFILE FILE…</p><p>&emsp;&emsp;&emsp;&emsp;参考RFILE文件的权限，将FILE的修改为同RFILE</p><h3 id="修改文件的属主和属组（仅root可用）"><a href="#修改文件的属主和属组（仅root可用）" class="headerlink" title="修改文件的属主和属组（仅root可用）"></a>修改文件的属主和属组（仅root可用）</h3><p>&emsp;&emsp;修改文件的属主：chwon</p><p>&emsp;&emsp;&emsp;&emsp;chown [OPTION]… [OWNER][:[GROUP]] FILE…</p><p>&emsp;&emsp;&emsp;&emsp;用法：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;OWNER</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;OWNER:GROUP</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;:GROUP</p><p>&emsp;&emsp;&emsp;&emsp;注意：命令中的冒号可以用.替换</p><p>&emsp;&emsp;&emsp;&emsp;-R：递归修改</p><p>&emsp;&emsp;&emsp;&emsp;chown [OPTION]… –reference=RFILE FILE…：参考修改</p><p>&emsp;&emsp;修改文件的属组：chgrp</p><p>&emsp;&emsp;&emsp;&emsp;chgrp [OPTION]… GROUP FILE…</p><p>&emsp;&emsp;&emsp;&emsp;chgrp [OPTION]… –reference=RFILE FILE…</p><p>&emsp;&emsp;&emsp;&emsp;-R：递归修改</p><h3 id="文件或目录创建时的遮罩码：umask"><a href="#文件或目录创建时的遮罩码：umask" class="headerlink" title="文件或目录创建时的遮罩码：umask"></a>文件或目录创建时的遮罩码：umask</h3><p>&emsp;&emsp;对于文件来说创建文件默认权限为：666-umask</p><p>&emsp;&emsp;&emsp;&emsp;注意：如果某类用户的权限减得的结果中存在x权限，则将其权限+1。</p><p>&emsp;&emsp;&emsp;&emsp;root用户默认uamsk：022</p><p>&emsp;&emsp;&emsp;&emsp;普通用户：002</p><p>&emsp;&emsp;对于目录来说创建时的默认权限为：777-umask</p><p>&emsp;&emsp;命令umask</p><p>&emsp;&emsp;&emsp;&emsp;umask ：查看当前的umask值</p><p>&emsp;&emsp;&emsp;&emsp;umask #：设定当前umask值</p><p>&emsp;&emsp;注意：umask的默认定义在/etc/profile文件中，在命令行中定义的关闭终端不会保存</p><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第4集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Linux的文件管理，管道，用户组管理，用户权限管理&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第3集</title>
    <link href="https://zhangdashuo.github.io/2018/07/20/redhat03/"/>
    <id>https://zhangdashuo.github.io/2018/07/20/redhat03/</id>
    <published>2018-07-20T06:03:56.000Z</published>
    <updated>2018-07-27T13:32:57.753Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第3集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>Linux的文件系统，系统管理类命令，bash基础特性<br><a id="more"></a> </excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""> </the></p><h2 id="Linux文件系统及文件类型"><a href="#Linux文件系统及文件类型" class="headerlink" title="Linux文件系统及文件类型"></a>Linux文件系统及文件类型</h2><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><p>在windows下对于硬盘的分区格式已经很了解了，一般C盘为系统盘，大约分给系统盘60G-80G即可，剩下的就是D盘E盘F盘啥的这个就根据自己的喜好和自己物理硬盘的大小进行分割就好。注意给磁盘分区后越靠近C盘的位置磁盘操作就越快，（对于磁盘的详细讲解可以关注后面的博客更新的内容），所以C盘安装系统，相应的可以把软件安装到D盘。而Linux下采用的是根文件系统（rootfs）。即所有的目录全部由根进行衍生。但这并不代表了Linux的文件系统不需要分区，对于Linux也是要分系统分区和其他数据分区的，通常内核启动之后就会寻找系统分区并将该分区挂载为根，对于其他分区的数据都是通过挂载的方式来挂载到根上，对于磁盘的操作在后期详细讲解。这里来说Linux的根下的目录结构，对Linux的文件有所了解。</p><p>对于Linux各发行版的根目录结构都很类似，他们都遵循由LSB（Linux standerd base）制定的FHS（File system hierarchy standard）标准来进行文件的规划的。对于Linux的目录结构大家可以查看该说明，进行详细的了解。以我的系统Centos来说根目录下的文件有：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ ls /</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure><p>下面来说根目录下每个文件夹所放置的内容：</p><p>/boot：Static files of the boot loader</p><p>&emsp;&emsp;引导文件存放目录，内核文件（VMlinuz），引导加载器（bootloader，grub）都存放于此文件。至于系统是如何引导启动的会在小红帽后面集中有所说明。</p><p>/bin：Essential user command binaries (for use by allusers)</p><p>&emsp;&emsp;供所有用户使用的基本二进制命令，不能关联至独立分区，该目录中存放的程序为操作系统启动就会用到的程序。</p><p>/lib：Essential shared libraries and kernel modules</p><p>&emsp;&emsp;基本共享库文件，以及内核模块文件（/lib/modules）</p><p>/sbin:System binaries</p><p>&emsp;&emsp;管理类的基本命令，不能关联至独立分区，该目录中存放的程序为操作系统启动就会用到的程序。</p><p>/lib64：Alternate（替代的） format essential shared libraries(optional)</p><p>&emsp;&emsp;专用于X86_64系统上的辅助共享库文件存放位置。</p><p>/etc：Host-specific system configuration</p><p>&emsp;&emsp;主机配置文件目录（里面的文件都为纯文本文件）</p><p>/home：User home directories (optional)</p><p>&emsp;&emsp;普通用户的家目录存放位置。</p><p>/root：Home directory for the root user (optional)</p><p>&emsp;&emsp;管理员的家目录。这里标明该文件为可选的。在一些unix系统下管理员确实是没有家目录的，因为管理员的权限太大了，所以通常管理员不会直接登陆系统，自然也就不需要家目录了。</p><p>/media：Mount point for removeable media</p><p>&emsp;&emsp;便携式移动设备的挂载点。通常我们的优盘挂载系统之后都会在该目录下。</p><p>/mnt：Mount point for a temporarily mounted filesystem</p><p>&emsp;&emsp;临时文件系统的挂载点。比如我们要把一个主机的硬盘拆下来放到另一个主机去操作通常该硬盘会挂载到该目录下。</p><p>/dev：Device files</p><p> &emsp;&emsp;设备文件及特殊文件存放位置。来看一下该目录下的文件吧：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ ls /dev/ -l</span><br><span class="line">total 0</span><br><span class="line">crw-------. 1 root    root     10, 235 Jul 20 22:42 autofs</span><br><span class="line">crw-------. 1 root    root     10, 234 Jul 20 22:42 btrfs-control</span><br><span class="line">lrwxrwxrwx. 1 root    root           3 Jul 20 22:42 cdrom -&gt; sr0</span><br><span class="line">drwxr-xr-x. 2 root    root         100 Jul 20 22:42 centos</span><br><span class="line">drwxr-xr-x. 2 root    root        2820 Jul 20 22:42 char</span><br><span class="line">crw-------. 1 root    root      5,   1 Jul 20 22:42 console</span><br><span class="line">brw-rw----. 1 root    disk    253,   0 Jul 20 22:42 dm-0</span><br><span class="line">brw-rw----. 1 root    disk    253,   1 Jul 20 22:42 dm-1</span><br><span class="line">brw-rw----. 1 root    disk    253,   2 Jul 20 22:42 dm-2</span><br></pre></td></tr></table></figure><p>在这些设备中的文件类型大部分为b，和c。</p><p>&emsp;&emsp;b：block device 块设备即随机访问的设备。随机访问的意思是比如在硬盘中放着123三个电影，如果要看第3个电影不需要先看1再看2才能看3，这就是随机访问。</p><p>&emsp;&emsp;c：character device 字符设备即线性访问的设备。线性访问的设备比如键盘鼠标等。如果键盘键入的值不按你敲击的顺序恐怕这个电脑离被砸已经不远了。</p><p>/opt：Add-on（附加的） application software packages</p><p>&emsp;&emsp;第三方应用程序安装位置。早些的oracle就是安装到该目录下的。</p><p>/srv：Data for services provided by this system</p><p>&emsp;&emsp;系统上运行的服务用到的数据存放位置。</p><p>/tmp：Temporary files</p><p>&emsp;&emsp;临时文件存放位置，对所有用户开放各种权限。看一下该目录的权限：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ ls -ld /tmp/</span><br><span class="line">drwxrwxrwt. 18 root root 4096 Jul 20 23:24 /tmp/</span><br></pre></td></tr></table></figure><p>可以发现该文件的类型有个t对于t的权限会在小红帽后面讲到。</p><p>注意：以上文件除了/boot，/home之外都不可独立分区。</p><p>/usr：/usr is shareable, read-only data</p><p>&emsp;&emsp;对于/usr又是一个层级结构。/usr is the second major section of the filesystem。它是全局共享只读数据的存放目录。</p><p>&emsp;&emsp;对于该目录下的一些文件说明：</p><p>&emsp;&emsp;bin，sbin：保证系统拥有完整功能而提供的应用程序。</p><p>&emsp;&emsp;lib，lib64：为这些程序的运行提供的库文件。</p><p>&emsp;&emsp;include：Header files included by C programs</p><p>&emsp;&emsp;&emsp;&emsp;C程序的头文件所存放的位置。头文件是用来描述库文件的打开姿势，描述程序接口的调用方式，及说明要调用哪些库文件，并说明调用该库时以什么方式调用。</p><p>&emsp;&emsp;local：Local hierarchy (empty after main installation)</p><p>&emsp;&emsp;&emsp;&emsp;第三方程序的安装目录，我的博客系统就是安装在该目录下的。这个目录下又是一个独立的层级结构，在该目录下也会有：bin，sbin，lib，lib64，etc，share</p><p>/var：contains variable data files.经常变化的数据存放位置。</p><p>&emsp;&emsp;cache：Application cache data 应用程序缓存数据目录。</p><p>&emsp;&emsp;lib：Variable state information 应用程序状态数据信息。</p><p>&emsp;&emsp;local：Variable data for /usr/local 专用于为/usr/local下的应用程序存储可变数据。</p><p>&emsp;&emsp;lock：Lock files 锁文件存放目录。</p><p>&emsp;&emsp;log：Log files and directories 日志文件和目录</p><p>&emsp;&emsp;opt：Variable data for /opt 专用于为/opt下的应用程序存储可变数据。</p><p>&emsp;&emsp;run：Data relevant（有关的） to running processes 运行中的进程相关的数据，通常用于存储进程的PID文件。</p><p>&emsp;&emsp;spool：Application spool data 应用数据的缓冲池。</p><p>&emsp;&emsp;tmp：Temporary files preserved between system reboots 保存系统两次重启之间产生的临时数据。</p><p>/proc：Kernel and process information virtual filesystem 用于输出内核于进程信息相关的虚拟文件系统。</p><p>/sys：用于输出当前系统上硬件设备相关信息的虚拟文件系统。例如块设备，蓝牙设备，网络设备等。</p><h3 id="Linux上的应用程序的组成部分"><a href="#Linux上的应用程序的组成部分" class="headerlink" title="Linux上的应用程序的组成部分"></a>Linux上的应用程序的组成部分</h3><p>Linux下每个安装好的程序都应该有如下部分：</p><p>&emsp;&emsp;二进制程序：/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin等目录下的可执行程序。</p><p>&emsp;&emsp;库文件：/lib，/lib64，/usr/lib，/usr/lib64，/usr/local/lib，/usr/local/lib64等目录下。</p><p>&emsp;&emsp;配置文件：/etc，/etc/DIRECTORY，/usr/local/etc等目录下。</p><p>&emsp;&emsp;帮助文件：/usr/local/man，/usr/local/doc，/usr/local/share/man，/usr/local/share/doc等目录下。</p><h3 id="Linux下的文件类型"><a href="#Linux下的文件类型" class="headerlink" title="Linux下的文件类型"></a>Linux下的文件类型</h3><p>使用<code>ls -l</code>命令可以查看该文件的文件类型。Linux的文件类型有如下几种：</p><p>&emsp;&emsp;-(f)：普通文件</p><p>&emsp;&emsp;d：目录文件</p><p>&emsp;&emsp;b：块设备文件，这类文件只有元数据而没有真正的数据，因为他们只是设备的访问入口而已。</p><p>&emsp;&emsp;c：字符设备，和块设备的属性类似。</p><p>&emsp;&emsp;l：符号链接文件</p><p>&emsp;&emsp;p：管道文件：FIFO</p><p>&emsp;&emsp;s：套接字文件</p><h2 id="bash基础特性及基础命令"><a href="#bash基础特性及基础命令" class="headerlink" title="bash基础特性及基础命令"></a>bash基础特性及基础命令</h2><h3 id="目录管理类命令"><a href="#目录管理类命令" class="headerlink" title="目录管理类命令"></a>目录管理类命令</h3><p>命令：cd，pwd，ls，mkdir，rmdir，tree。</p><p>mkdir [OPTION]… DIRECTORY… ：make directories 创建目录</p><p>&emsp;&emsp;-p, –parents：该目录名再其上级目录中存在，则创建时不报错，且可自动创建所需的各目录。</p><p>&emsp;&emsp;-v, –verbose：显示详细信息。</p><p>&emsp;&emsp;-m, –mode=MODE：创建目录时同时指定其权限。</p><p>rmdir [OPTION]… DIRECTORY…：remove empty directories 删除空目录</p><p>&emsp;&emsp;-v, –verbose：显示详细过程。</p><p>&emsp;&emsp;-p, –parents：递归删除。这个命令基本很少用。看一个例子吧：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost tmp]$ tree x #显示目录树状结构</span><br><span class="line">x</span><br><span class="line">└── y</span><br><span class="line">    └── z</span><br><span class="line">        └── a</span><br><span class="line"></span><br><span class="line">3 directories, 0 files</span><br><span class="line">[zhangshuo@localhost tmp]$ rmdir -p x/y/z/a #使用-p选项进行递归删除</span><br><span class="line">[zhangshuo@localhost tmp]$ ls -ld x#因为a目录为空，所以删除，删除之后发现z目录为空所以也删除，同样所以x也被删除</span><br><span class="line">ls: cannot access x: No such file or directory</span><br></pre></td></tr></table></figure><p>tree [OPTION]… DIRECTORY… ：显示目录的树状结构，它的选项很多一般我们只会用到下面几个：</p><p>&emsp;&emsp;-d：只显示目录。</p><p>&emsp;&emsp;-L：限制层级数目。</p><p>&emsp;&emsp;-P pattern：只显示由指定pattern匹配到的路径。</p><h3 id="文本文件查看类命令补充"><a href="#文本文件查看类命令补充" class="headerlink" title="文本文件查看类命令补充"></a>文本文件查看类命令补充</h3><p>命令：cat，tac，more，less，tail，head</p><p>more [options] file […]：more查看文本在翻到最后面时直接退出。</p><p>&emsp;&emsp;-d：显示翻页及退出提示。</p><p>less [options] file […]：和man的操作类似，因为man对于帮助文档的显示就是调用的less命令。</p><p>head [options] file […]：显示文章的首部，默认为显示文件的前10行。</p><p>&emsp;&emsp;-c #：指定获取前#字节。</p><p>&emsp;&emsp;-n #：指定获取前#行。</p><p>&emsp;&emsp;-#：指定获取前#行。</p><p>tail [options] file […]：显示文章的尾部，默认为显示文件的后10行。</p><p>&emsp;&emsp;-c #：指定获取后#字节。</p><p>&emsp;&emsp;-n #：指定获取后#行。</p><p>&emsp;&emsp;-#：指定获取后#行。</p><p>&emsp;&emsp;-f：跟踪显示文件新追加的内容，通常对于日志文件的产看对于该选项使用较多。</p><h3 id="文件的时间戳管理工具"><a href="#文件的时间戳管理工具" class="headerlink" title="文件的时间戳管理工具"></a>文件的时间戳管理工具</h3><p>命令：touch</p><p>在上集的文件系统部分对于文件的数据有所描述，即对于Linux下的每个文件都由metadata（源数据），data（数据组成）。对于文件的状态可以使用stat命令进行查看。</p><p>stat [OPTION]… FILE…：display file or file system status 显示文件的状态信息。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost hexo]$ stat _config.yml #stat命令来查看_config.yml配置文件的信息</span><br><span class="line">  File: ‘_config.yml’#文件名</span><br><span class="line">  Size: 2512（大小）    Blocks: 8（磁盘块大小）   IO Block: 4096（IO块大小）  regular file</span><br><span class="line">Device: fd02h/64770dInode: 134279906（inode号）   Links: 1（文件被硬链接的次数）</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/zhangshuo)（属主）   Gid: ( 1000/zhangshuo)（属组）</span><br><span class="line">Context: unconfined_u:object_r:user_home_t:s0</span><br><span class="line">Access: 2018-07-20 13:11:22.033729289 +0800（访问时间）</span><br><span class="line">Modify: 2018-07-20 13:11:18.115237469 +0800（修改时间）</span><br><span class="line">Change: 2018-07-20 13:11:18.124987656 +0800（改变时间）</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>对于Linux下每个文件都有三个时间戳：</p><p>&emsp;&emsp;Access time：访问时间，简写为atime  表示文件最近一次被读取的时间。</p><p>&emsp;&emsp;Modify time：修改时间，简写为mtime 表示文件最近一次被修改的时间。这里修改的内容为文件的数据内容。</p><p>&emsp;&emsp;Change time：改变时间，简写为ctime 表示文件最近一次源数据发生改变的时间。只要文件的atime或是mtime发生改变则ctime比发生改变。</p><p>touch [OPTION]… FILE…：change file timestamps touch命令用于改变文件的时间戳。</p><p>&emsp;&emsp;-a：只修改访问时间</p><p>&emsp;&emsp;-m：只修改修改时间</p><p>&emsp;&emsp;-t STAMP：</p><p>&emsp;&emsp;&emsp;&emsp;use [[CC]YY]MMDDhhmm[.ss] instead of current time：修改为指定的时间。</p><p>&emsp;&emsp;-c：如果文件不存在，则不予创建。</p><h3 id="linux的bash基础特性"><a href="#linux的bash基础特性" class="headerlink" title="linux的bash基础特性"></a>linux的bash基础特性</h3><ol><li><p>命令历史</p><p>命令：<code>history</code>对于该命令相关的所包含的环境变量有如下几个：</p></li></ol><p>&emsp;&emsp;&emsp;&emsp;HISTSIZE：定义命令历史记录的条数。</p><p>&emsp;&emsp;&emsp;&emsp;HISTFILE：定义命令历史所保存的文件。通常文件为：~/.bash_history</p><p>&emsp;&emsp;&emsp;&emsp;HISTFILESIZE：命令历史文件记录历史的条数。</p><p>&emsp;&emsp;&emsp;&emsp;HISTCONTROL：命令历史的记录方式。</p><p>&emsp;&emsp;history：Display or manipulate（操作） the history list.</p><p>&emsp;&emsp;用法：<code>history [-c][-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]</code></p><p>&emsp;&emsp;&emsp;&emsp;-d OFFSET：删除某条命令历史。</p><p>&emsp;&emsp;&emsp;&emsp;-c：清空整个命令历史。</p><p>&emsp;&emsp;&emsp;&emsp;#：显示历史中最近的#条命令。</p><p>&emsp;&emsp;&emsp;&emsp;-a：手动追加当前会话缓冲区的命令历史至历史文件中。</p><p>&emsp;&emsp;调用命令历史中的命令：</p><p>&emsp;&emsp;&emsp;&emsp;!#：重复执行第#条指令。</p><p>&emsp;&emsp;&emsp;&emsp;!!：重复执行上一条命令。</p><p>&emsp;&emsp;&emsp;&emsp;!string：最近一次以string开头的指令。</p><p>&emsp;&emsp;调用上一条命令的最后一个参数：</p><p>&emsp;&emsp;&emsp;&emsp;!$：</p><p>&emsp;&emsp;&emsp;&emsp;ESC，.：按一下ESC松开然后再按.</p><p>&emsp;&emsp;&emsp;&emsp;ALT+.：按着ALT不松开，然后按.</p><p>&emsp;&emsp;控制命令历史的记录方式：</p><p>&emsp;&emsp;&emsp;&emsp;环境变量：HISTCONTROL</p><p>&emsp;&emsp;&emsp;&emsp;它的取值所表示的意义：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ignoredups：忽略重复的命令（连续且完全相同的方为重复）。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ignorespace：忽略空格开头的命令。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ignoreboth：上述都生效。</p><p>&emsp;&emsp;&emsp;&emsp;更改环境变量的值的方式：<code>export HISTCONTROL=&#39;ignoreboth&#39;</code></p><ol start="2"><li><p>命令补全</p><p>bash执行命令的过程上一级中有所说明这里再提一下：</p></li></ol><p>&emsp;&emsp;&emsp;&emsp;对于内部命令：直接调用运行</p><p>&emsp;&emsp;&emsp;&emsp;对于外部命令：需要在PATH环境变量中规定的路径从左至右进行查找，第一次找到的即为要执行的命令。所以命令补全的机制也是基于此。</p><p>&emsp;&emsp;&emsp;&emsp;直接补全：按TAB键，用户给定的字符串只有一条唯一对应的命令，以用户给定的字符串为开头。如果对应的命令不唯一，则再次按TAB键可以列表的形式给出。</p><ol start="3"><li><p>路径补全</p><p>把用户给出的字符串当作路径开关，并在其指定上级目录下搜索以指定的字符串开头的文件名。用法和命令补全类似。</p><p>建议：对于命令补全和路径补全建议经常使用。这样不仅可以提高效率而且可以保证命令执行的准确性。</p></li><li><p>命令行展开</p><p>上集说到一个命令行展开那就是”~”,它表示用户的主目录。这里再进行总结补充：</p></li></ol><p>&emsp;&emsp;&emsp;&emsp;~：展开为用户的主目录。</p><p>&emsp;&emsp;&emsp;&emsp;~ USERNAME：展开为指定用户的主目录。</p><p>&emsp;&emsp;&emsp;&emsp;{}：可承载一个以逗号分隔的列表，并将其展开为多个路径，比如：/tmp/{a,b} 则展开为：/tmp/a，/tmp/b</p><p>   对于花括号展开的举例如下：</p>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost test]$ ls #test目录下为空</span><br><span class="line"><span class="meta">#</span><span class="bash">创建 x/y1，x/y2，x/y1/a，x/y1/b，x/y2/a，x/y2/b</span></span><br><span class="line">[zhangshuo@localhost test]$ mkdir -p x/&#123;y1,y2&#125;/&#123;a,b&#125;</span><br><span class="line">[zhangshuo@localhost test]$ tree x</span><br><span class="line">x</span><br><span class="line">├── y1</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── b</span><br><span class="line">└── y2</span><br><span class="line">    ├── a</span><br><span class="line">    └── b</span><br><span class="line">6 directories, 0 files</span><br><span class="line"><span class="meta">#</span><span class="bash">创建ab_ef，ab_gh，cd_ef，cd_gh四个文件夹</span></span><br><span class="line">[zhangshuo@localhost test]$ mkdir -p &#123;ab,cd&#125;_&#123;ef,gh&#125;</span><br><span class="line">[zhangshuo@localhost test]$ ls</span><br><span class="line">ab_ef  ab_gh  cd_ef  cd_gh  x</span><br><span class="line"><span class="meta">#</span><span class="bash">创建bin，sbin，usr，usr/bin，usr/sbin。</span></span><br><span class="line">[zhangshuo@localhost test]$ mkdir -p &#123;bin,sbin,usr/&#123;bin,sbin&#125;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">最终的结果如下</span></span><br><span class="line">[zhangshuo@localhost test]$ tree ../test/</span><br><span class="line">../test/</span><br><span class="line">├── ab_ef</span><br><span class="line">├── ab_gh</span><br><span class="line">├── bin</span><br><span class="line">├── cd_ef</span><br><span class="line">├── cd_gh</span><br><span class="line">├── sbin</span><br><span class="line">├── usr</span><br><span class="line">│   ├── bin</span><br><span class="line">│   └── sbin</span><br><span class="line">└── x</span><br><span class="line">    ├── y1</span><br><span class="line">    │   ├── a</span><br><span class="line">    │   └── b</span><br><span class="line">    └── y2</span><br><span class="line">        ├── a</span><br><span class="line">        └── b</span><br><span class="line">16 directories, 0 files</span><br></pre></td></tr></table></figure><ol start="5"><li><p>命令的执行结果状态</p><p>命令的执行结果状态有两种：</p></li></ol><p>&emsp;&emsp;&emsp;&emsp;要么成功：</p><p>&emsp;&emsp;&emsp;&emsp;要么失败：</p><p>&emsp;&emsp;在bash中，使用特殊变量$?保存最近一条命令的执行状态结果。</p><p>&emsp;&emsp;&emsp;&emsp;0：表示成功过</p><p>&emsp;&emsp;&emsp;&emsp;1-255：都表示失败</p><p>&emsp;&emsp;程序的执行有两类结果：</p><p>&emsp;&emsp;&emsp;&emsp;一种程序的返回值：</p><p>&emsp;&emsp;&emsp;&emsp;一种程序的执行状态结果：</p><p>&emsp;&emsp;&emsp;&emsp;比如：</p>   <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost test]$ ls /var #程序正常运行</span><br><span class="line">account  cache  db     ftp    gopher    lib    lock  mail  opt       run    target  yp</span><br><span class="line">adm      crash  empty  games  kerberos  local  log   nis   preserve  spool  tmp</span><br><span class="line">[zhangshuo@localhost test]$ echo $? #执行状态返回结果</span><br><span class="line">0 #表示成功</span><br><span class="line">[zhangshuo@localhost test]$ lls /var #命令书写错误</span><br><span class="line">bash: lls: command not found...</span><br><span class="line">Similar command is: 'ls'</span><br><span class="line">[zhangshuo@localhost test]$ echo $?</span><br><span class="line">127 #状态返回结果不为0表示失败</span><br><span class="line">[zhangshuo@localhost test]$ ls /varrr</span><br><span class="line">ls: cannot access /varrr: No such file or directory</span><br><span class="line">[zhangshuo@localhost test]$ echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第3集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;Linux的文件系统，系统管理类命令，bash基础特性&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第2集</title>
    <link href="https://zhangdashuo.github.io/2018/07/18/redhat02/"/>
    <id>https://zhangdashuo.github.io/2018/07/18/redhat02/</id>
    <published>2018-07-18T13:55:34.000Z</published>
    <updated>2018-07-27T13:33:08.861Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第2集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>OS Linux发行版，Linux系统基础使用入门，Linux命令帮助<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="Linux基础入门（一）"><a href="#Linux基础入门（一）" class="headerlink" title="Linux基础入门（一）"></a>Linux基础入门（一）</h2><h3 id="POSIX规范"><a href="#POSIX规范" class="headerlink" title="POSIX规范"></a>POSIX规范</h3><p>POSIX表示可移植操作系统接口(Portable Operating System Interface of UNIX，缩写为 POSIX ），POSIX标准定义了操作系统应该为应用程序提供的接口标准，是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。</p><p>POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统（即使是来自另一个厂商）上编译执行。</p><p>我们都知道window的程序是不可以在Linux系统下运行的（前段时间在Linux下安装微信或是QQ啥的，其实直接运行是不可以的，如果要运行QQ是需要wine叫做红酒杯的容器，在这个容器之上才可以运行特殊的windows程序）。我们都知道windows可执行程序的格式为EXE或是MSI格式，运行的库的格式为.dll(dynamic link library)，而在Linux下可执行的程序格式为ELF格式的（拿ls命令来说吧，在终端下直接运行<strong>file /bin/ls</strong>可以看到ls可执行文件的格式为ELF格式），Linux所运行的库的格式为.so（shard object 共享对象）。其实这两者的不同在上次已经说过叫做ABI接口不同。对于POSIX规范其实规定的是API接口的规范，如果windows和Linux的库调用方式相同（当然其内部的实现方式是可以不同的），这样程序员写出的程序就可以在不同的操作系统之间进行编译，实现了程序的移植性和通用性。</p><h3 id="编程语言层级"><a href="#编程语言层级" class="headerlink" title="编程语言层级"></a>编程语言层级</h3><p>程序是由指令+数据组成的，通常指令都为只读的，而数据是可以读写的。其实程序的主要作用就是对我们所提供的原始数据进行加工，加工为我们所需要数据格式或是运行结果。所以也可以说程序是由算法+数据结构组成的。上一集也提到过操作系统的层级结构如图所示：</p><p><img src="/2018/07/18/redhat02/oscengjijiegou.png" alt=""></p><p>可以看到对于程序的编写可以面向系统调用层次，或是库调用层次进行编程。系统调用或是库调用是允许被调用的程序，他们只提供程序而不能提供数据，这样也是可以多个程序调用的保障。采用这种调用方式可以在内存中对相同调用的库只进行一次存储，这样就会极大的节省内存。对于这两种调用来说其实就是更底层的调用，系统调用和库调用（对于Linux下的库通常为glibc库）通常都是C写的性能很好但是需要程序员对内存或是运行精心的设计，这对程序员是一个很大的工作，同时对于程序来说也很可能有bug。对于网络中有一种攻击方式叫做缓冲区溢出，这种方式就是利用程序的bug来覆盖内存中的某些数据从而侵入其他系统的操作。但是这种更底层的方式通常运行效率比较高，但是程序不易开发。对于对性能要求较高的系统级程序比如MySQL这类数据库软件通常都是直接面向系统调用或是库调用开发完成的。由于这种程序开发方式过于底层，不易编程所以在此基础上出现了很多更高级的编程语言，这类语言是直接面向该种语言的解释器或是虚拟机编程的所以是高级的语言，比如JAVA PYTHON PHP等，这种方式因为要运行虚拟机或是解释器还要运行垃圾收集程序等所以这种语言编写的程序通常效率会比较低。但是对于那些对性能要求不高的终端程序的开发来说是非常高效的。由于这些语言是面向虚拟机或是解释器和硬件没有任何关系(当然解释器或是虚拟机也是由C语言编写的，需要考虑硬件的兼容性的)，这种编写的程序一般就是一次编写到处运行。</p><p>编程语言层次总结如下：</p><blockquote><ul><li>汇编语言：微码编程<ul><li>系统中某些与硬件相关的代码，驱动程序开发</li></ul></li><li>高级语言：C或C++<ul><li>系统级应用，和对性能要求较高驱动程序开发等</li></ul></li><li>高级应用：JAVA,Python，PHP<ul><li>开发应用程序，一次编写到处运行</li></ul></li></ul></blockquote><h3 id="Linux的发行版"><a href="#Linux的发行版" class="headerlink" title="Linux的发行版"></a>Linux的发行版</h3><p>从操作系统的层级结构可以知道对于Linux操作系统来说由kernel，glibc，和一个人机交互的UI程序，通常Linux系统下的UI程序为bash（CLI），可以试想如果我们要想学Linux我们拿到的只有这些源程序。先不说学Linux就先将这些零件组装成一个可以运行的操作系统怎么也要需要半年或是更多的时间的吧。所以如果对于新手这样学Linux…我想这样能学Linux的人也就更少了。</p><p>所以就有一些有能力的人从中看到商机，他们负责将这些源程序进行编译，组合在一张光盘内，而对于使用者可以直接将光盘插入电脑然后下一步下一步就能完成操作系统的安装。这样打包发行的企业叫做发行商，而他们所做的系统叫做发行版。目前主流的发行版有如下几个：</p><blockquote><ul><li>SlackWare：<img src="/2018/07/18/redhat02/slackware.png" alt=""><ul><li>基于SlackWare的二次发行版：S.U.S.E  <img src="/2018/07/18/redhat02/suse.png" alt=""></li><li>基于S.U.S.E的二次发行版：OpenSUSE <img src="/2018/07/18/redhat02/opensuse.png" alt=""></li><li>对于suse（一只绿色的大蜥蜴）通常在欧洲国家比较流行，在国内对于华为公司他们在欧洲会有很多项目所以华为公司通常都会要求会S.U.S.E</li></ul></li><li>debian：<img src="/2018/07/18/redhat02/debian.png" alt=""><ul><li>debian目前采用的还是社区维护方式，没有企业作为后台支持，但这也是最具有原汁原味的Linux发行版。</li><li>基于debian的最著名的发行版，反正目前实验室用的全是这个版本：ubuntu <img src="/2018/07/18/redhat02/ubuntu.png" alt=""></li><li>基于ubuntu的二次发行版，MINT这个版本作为桌面版确实漂亮，我在U盘中安装系统就是这个： <img src="/2018/07/18/redhat02/mint.png" alt=""></li></ul></li><li>Redhat：<img src="/2018/07/18/redhat02/redhat.png" alt=""><ul><li>redhat1993年成立（和我一样大的岁数，这也是我为什么如此喜欢redhat的缘故），是目前最流行的服务器运行版本。因为在服务器上运行所以要求较高的稳定性，通常18个月发行一个新版本。</li><li>redhat公司在 2003年成立Fedora（个人桌面版本）：<img src="/2018/07/18/redhat02/fedora.png" alt=""></li><li>主要是测试新版本的bug和测试新软件，通常每6个月发行一个新版本。</li><li>基于redhat的二次编译发行版 CentOS ：<img src="/2018/07/18/redhat02/centos.png" alt=""></li><li>国内服务器目前使用最对的版本。我的虚拟机中安装的也是这个版本。</li></ul></li><li>ArchLinux：<img src="/2018/07/18/redhat02/archlinux.png" alt=""><ul><li>最近出现的发行版，它的特点是有轻量级的系统和精巧的程序包管理器。</li></ul></li><li>Gentoo：<img src="/2018/07/18/redhat02/gentoo.png" alt=""><ul><li>Gentoo是门槛比较高的操作系统，通常它的所有软件都需要自行编译安装，它认为这样才可以更好的发挥硬件的性能。</li></ul></li><li>Android：<img src="/2018/07/18/redhat02/android.png" alt=""><ul><li>对于安卓肯定不陌生。它的组成是linux内核+busybox+java虚拟机组成，所以他也算是linux的一个版本吧。</li></ul></li></ul></blockquote><h3 id="开源协定"><a href="#开源协定" class="headerlink" title="开源协定"></a>开源协定</h3><p>GNU当初进行软件共产主义运动的目的就是实现软件的自由话，开源协定的目的就是实现软件的自由话，自由意味着对开源软件可以自由学习和修改（也就是支持任何打开方式）自由分发，自由创建衍生版。</p><p>这里只介绍一些开源协定：</p><blockquote><ul><li>GPL：</li><li>LGPL：</li><li>Apache：</li><li>BSD：</li></ul></blockquote><h3 id="Linux的哲学思想"><a href="#Linux的哲学思想" class="headerlink" title="Linux的哲学思想"></a>Linux的哲学思想</h3><p>了解Linux的哲学思想可以指导我们如何学习Linux，及如何更快的了解其本质。</p><p>  [x] 一切皆文件</p><p>  把几乎所资源包括硬件设备都组织为文件格式，可以对任意设备进行类似文件的操作，read，close，open，close等操作。</p><p>  [x] 由众多单一目的的小程序组成</p><p>  一个程序只实现一个功能，而且要做好，组合小程序完成复杂任务。</p><p>  [x] 尽量避免跟用户交互</p><p>  目标：实现脚本编程，可以自动完成某些功能。</p><p>  [x] 使用纯文本文件保存配置信息</p><p>  目标：一款合用的文本编辑器即能完成系统的配置工作。</p><h3 id="获取Centos的发行版"><a href="#获取Centos的发行版" class="headerlink" title="获取Centos的发行版"></a>获取Centos的发行版</h3><p>通过国内的镜像站点即可获得Centos的发行版。</p><p><a href="https://mirrors.aliyun.com/centos/" target="_blank" rel="noopener">阿里云镜像站</a></p><p><a href="http://mirrors.163.com/" target="_blank" rel="noopener">163镜像站</a></p><h2 id="Linux基础入门（二）"><a href="#Linux基础入门（二）" class="headerlink" title="Linux基础入门（二）"></a>Linux基础入门（二）</h2><h3 id="Linux的终端类型"><a href="#Linux的终端类型" class="headerlink" title="Linux的终端类型"></a>Linux的终端类型</h3><p>我们在使用Linux时其实经常和终端打交道。终端是用户与主机交互必然要用到的设备。在早些UNIX的时代那是的大型机为了实现多用户的方式就设置了分屏器，分屏器中有很多接口可以接入显示器设备和键盘设备。这样用户只要带着自己的显示器和键盘就可以登入系统。这就是UNIX的多用户多任务操作系统，在后来Linux也继承了UNIX的多任务多用户的模式，其实Linux叫做UNIX-Like操作系统，它的操作和UNIX还是非常像的。下面来说Linxu下的终端类型有如下几种：</p><blockquote><ul><li>物理终端：直接接入本机的显示器和键盘设备。在现代的Linux系统下物理终端只在系统启动时的运行结果的输出，而当系统完全启动之后就不会再使用了。物理终端的设备文件为：/dev/console</li><li>虚拟终端：附加在物理终端之上的以软件方式虚拟实现的终端，对于CentOS来说默认启动6个虚拟终端。按住Ctrl+Alt+F# #号的取值范围为[1,6]。虚拟终端的设备文件为：/dev/tty#。对于虚拟终端如图所示：<img src="/2018/07/18/redhat02/tty.png" alt=""></li><li>图形终端：附加在物理终端之上的以软件方式虚拟实现的终端，额外会提供桌面环境。对于图像终端就是我们安装好Linux如果安装了KDE或是GNOME桌面环境，然后开机所看到的桌面环境。</li><li>模拟终端：纯软件方式实现，而且不会附加在物理终端之上，而是附加在图形终端或远程终端。图形界面下打开的命令行接口，基于ssh协议或telnet协议等远程打开的界面都叫做模拟终端，模拟终端的设备路径为：/dev/pts/#。我这里使用的xshell登陆的服务器如图所示：<img src="/2018/07/18/redhat02/pts.png" alt=""></li></ul></blockquote><h3 id="交互式接口"><a href="#交互式接口" class="headerlink" title="交互式接口"></a>交互式接口</h3><p>终端是一个软件但是不是交互软件，启动终端后，在终端设备附加一个交互式应用程序，这个应用程序叫做交互式接口。</p><p>Linux下交互式接口有两类，一类为图形桌面（GUI），令一类为命令行接口（CLI）。</p><blockquote><ul><li>GUI图形接口：<br>就是我们启动Linux后的图形桌面，它是由X protocol，window manager，desktop（桌面系统）组成的。常见的Linux桌面系统主要有如下几种：<ol><li>GNOME：使用C语言在gtk下进行研发的（C,GTK）。</li><li>KDE：使用C++语言在QT下就行研发的（C++,QT）。</li><li>XFCE：轻量级桌面系统适用于嵌入式硬件资源比较差的环境，常见的ubuntu的xubutu的桌面环境就是XFCE。</li></ol></li><li>CLI命令行接口：<br>在命令行下我们登入系统系统就会给我们提供一个shell程序，shell程序是整个系统的外壳，通过它才可以和系统的内核打交道，所以起名为shell（壳，或是炮弹的壳）。常见的shell程序主要有如下几种：<ol><li>sh：由bourn研发，这个shell最早是unix的shell程序，因为它是最早的shell程序起名叫做shell牌shell。</li><li>csh：使用C语言进行研发，相对于sh提供更多的特性和接口。</li><li>ksh：由korn研发命名为ksh基于sh兼容csh的诸多特性，并提供更多的新特性。</li><li>bash：（bourn again shell）是sh的升级版，遵守GPL协定即完全开源。bash是目前Linux的默认shell程序。</li><li>zsh：虽然使用了最后一个字母，但是这个shell用的人很少。</li></ol></li></ul></blockquote><h3 id="查看系统当前使用的shell"><a href="#查看系统当前使用的shell" class="headerlink" title="查看系统当前使用的shell"></a>查看系统当前使用的shell</h3><p>系统当前使用的shell会保存在SHELL环境变量下，所以直接读取SHELL环境变量的值则可以查看当前系统所用的shell。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h3 id="显示当前系统所有可以使用的shell"><a href="#显示当前系统所有可以使用的shell" class="headerlink" title="显示当前系统所有可以使用的shell"></a>显示当前系统所有可以使用的shell</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/sbin/nologin</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/usr/sbin/nologin</span><br><span class="line">/bin/tcsh</span><br><span class="line">/bin/csh</span><br></pre></td></tr></table></figure><h3 id="bash的命令提示符"><a href="#bash的命令提示符" class="headerlink" title="bash的命令提示符"></a>bash的命令提示符</h3><p>我们打开任何一个终端登入系统之后都会看到<code>[zhangshuo@localhost ~]$</code> 这样的字样，这就是prompt，首先对于<code>[zhangshuo@localhost ~]</code>这个显示样子是由bash提供的，是由一个叫做PS1环境变量所定义的，我们可以看一下PS1所定义的内容如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ echo $PS1</span><br><span class="line">[\u@\h \W]\$</span><br></pre></td></tr></table></figure><p>对于这段不叫做提示符，这段后面的$符是真正的命令提示符。Linux的命令提示符有两种：</p><ol><li>普通用户的提示符：$</li><li>管理员的的提示符：#</li></ol><h3 id="shell运行程序的过程"><a href="#shell运行程序的过程" class="headerlink" title="shell运行程序的过程"></a>shell运行程序的过程</h3><p>shell要运行程序只需要在命令提示符下输入命令，然后按回车键即可运行程序。提交程序的过程为提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源并将其运行起来。程序其实是放在硬盘中的代码，但是程序在运行起来之后就表现为一个或多个进程。</p><p>shell中可执行的命令有两类：</p><ol><li>内建命令：由shell自带的，而且通过某命令行形式提供。</li><li>外部命令：在当前系统的某文件系统路径下有对应的可执行程序文件。对于外部命令可以使用which，whereis来查看该命令所在的位置（这个位置为可执行二进制程序所在的位置）。</li></ol><p>区别内部命令或外部命令的命令：</p><p><code>type COMMAND</code></p><p>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ type type</span><br><span class="line">type is a shell builtin</span><br></pre></td></tr></table></figure><h3 id="运行命令格式"><a href="#运行命令格式" class="headerlink" title="运行命令格式"></a>运行命令格式</h3><p><code>COMMAND [OPTIONS] [ARGUMENTS]</code></p><p>选项：用于启用或关闭命令的某个或某些功能，选项又分长选项和短选项。</p><p>&emsp;&emsp;短选项：-c ，例如ls命令的 -l ，-h 多个短选项可以合并使用，例如<code>ls -l -h</code>可合并使用为 <code>ls -lh</code></p><p>&emsp;&emsp;长选项：–word，例如ls命令的 –long,–human-readable</p><p>参数：命令的作用对象（给命令提供的数据）</p><p>注意：</p><ol><li>多个选项以及多个参数和命令之间都应该使用空白字符进行分割。</li><li>取消命令执行：Ctrl+c</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>计算机中的文件都有两类数据：</p><ol><li>元数据：metadata 文件的文件名，时间戳，大小，路径等外围特征都为元数据。</li><li>数据：data 就是文件中所存放的数据内容。</li></ol><h4 id="Linux下的文件格式"><a href="#Linux下的文件格式" class="headerlink" title="Linux下的文件格式"></a>Linux下的文件格式</h4><ol><li>文件名严格区分字符大小写：file1，File1，FILE1三个文件表示三个不同的文件。</li><li>文件名可使用除/以外的任意字符，不建议使用特殊字符。</li><li>文件名长度最长不能超过255个字符。</li><li>所有以.开头的文件都为隐藏文件。</li></ol><h4 id="Linux下的路径格式"><a href="#Linux下的路径格式" class="headerlink" title="Linux下的路径格式"></a>Linux下的路径格式</h4><ol><li>绝对路径：从根目录起始的路径。</li><li>相对路径：从当前位置起始的路径。当前位置的表示方式：（1）./（2）省略上述符号（3）..表示当前目录的上一级目录。</li><li>当前目录：current directory，也称作working directory ，登入系统之后会一直处于某个目录下，当前所处的目录就为当前目录或工作目录。</li></ol><p>查看当前目录的命令为：<code>pwd</code> （printing working directory 的首字母缩写）。</p><p>其实对于各个Linux的发行版来说它们的根目录的结构都很类似，因为他们都遵循LSB（Linux standard base）规范。目的是对于各个发行版都可以很快使用而保持linux的结构。</p><h2 id="Linux的命令帮助"><a href="#Linux的命令帮助" class="headerlink" title="Linux的命令帮助"></a>Linux的命令帮助</h2><p>Linux下的命令有成千上万个我们不可能都记住每个命令，包括每个命令的选项所表示的内容。所以我们一般记得需要完成相应的工作所使用的对应的命令的名字就行，当然对于常用的命令的选项格式还是需要记得的。所以知道命令名称查看该命令的详细使用方式时就需要查看该命令的帮助文档。</p><h3 id="对于内部命令帮助的获取"><a href="#对于内部命令帮助的获取" class="headerlink" title="对于内部命令帮助的获取"></a>对于内部命令帮助的获取</h3><p>使用：help COMMAND即可获取内部命令的使用帮助。</p><h3 id="对于外部命令帮助的获取"><a href="#对于外部命令帮助的获取" class="headerlink" title="对于外部命令帮助的获取"></a>对于外部命令帮助的获取</h3><ol><li>COMMAND –help 或是COMAND -h即可查看简要的帮助信息。</li><li>使用手册（manual）。使用方式：man COMAND</li><li>信息页。使用方式：info COMMAND</li><li>程序自身的帮助文档。程序包中的README INSTALL CHANGLELOG等文件中可以查看。</li><li>程序官方文档。</li><li>发行版的官方文档。</li><li>百度或是Google</li></ol><h3 id="程序运行过程和hash"><a href="#程序运行过程和hash" class="headerlink" title="程序运行过程和hash"></a>程序运行过程和hash</h3><p>上面的shell运行程序的过程也提到过，shell会寻找命令所在的位置然后运行。它的搜寻过程肯定不是在整个根目录下进行寻找，因为这样不仅浪费时间而且没有必要，因为通常可执行的文件一般都会放在固定的路径中，对于这些路径会在小红帽第三集中进行说明。所以shell寻找路径是有目的的寻找的，它只会在PATH环境变量中规定的路径进行搜索。查看自己的环境变量值可以使用<code>echo $PATH</code>来查看程序的搜索路径。</p><p>注意：shell对于PATH环境变量中的路径是按着自左至右的顺序去寻找，如果找到则停止寻找。</p><p>shell本身在查找到程序之后为了加速程序运行会将本次找到的命令路径结果会缓存至KV(KEY-VALUE，键值存储)中，当下次再次运行该命令时则直接在缓存中查找速度会更快。查看系统中的键值存储命令为：<code>hash</code>。如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ hash</span><br><span class="line">hitsCOMMAND   </span><br><span class="line">   1/usr/bin/man</span><br><span class="line">   2/usr/bin/ls</span><br><span class="line">   1/usr/bin/free</span><br><span class="line">   7/usr/bin/clear</span><br></pre></td></tr></table></figure><p>注意：当某程序被哈希时，若此时移动该程序则再次运行该命令会找不到该命令，即使移动后的位置在PATH环境变量中，此时应该清楚hash后重新运行该程序。清楚哈希缓存的命令为：<code>hash -r</code></p><h3 id="命令历史的管理"><a href="#命令历史的管理" class="headerlink" title="命令历史的管理"></a>命令历史的管理</h3><p>命令历史的作用是记录我们登陆系统之后所执行过的命令，登陆shell时，系统会读取命令历史文件中记录下的命令。历史文件为：<code>~/.bash_history</code>文件。登陆进shell后新执行的命令只会记录在缓存中，这些命令会在用户退出系统时追加至命令历史中。例如我的系统查看家目录下的.bash_history的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ cat .bash_history </span><br><span class="line">ifconfig</span><br><span class="line">ping www.baidu.com</span><br><span class="line">shutdown -r now</span><br><span class="line">ifconfig</span><br><span class="line">su - root</span><br><span class="line">exit</span><br><span class="line">su - root</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>查看目前缓存的命令为：<code>history</code>，我系统部分缓存的结果为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ history </span><br><span class="line">1  ifconfig</span><br><span class="line">2  ping www.baidu.com</span><br><span class="line">3  shutdown -r now</span><br><span class="line">4  ifconfig</span><br></pre></td></tr></table></figure><p>history命令的使用：</p><p>&emsp;&emsp;-a：追加本次会话新执行的命令历史列表至命令历史文件中。</p><p>&emsp;&emsp;-d：删除命令历史中指定偏移位置处的命令历史。</p><p>&emsp;&emsp;-c：清空命令历史。</p><h3 id="bash特性之一命令历史"><a href="#bash特性之一命令历史" class="headerlink" title="bash特性之一命令历史"></a>bash特性之一命令历史</h3><p>可以看到history命令的执行结果的命令都有序号，此时可以使用：!#:运行历史中第#条命令。!string：运行命令历史中最近一个以string开头的命令。!!:重复运行上一条执行的命令。</p><h3 id="外部命令的获取详解"><a href="#外部命令的获取详解" class="headerlink" title="外部命令的获取详解"></a>外部命令的获取详解</h3><ol><li>man COMMAND</li></ol><p>使用man命令查看所需命令的帮助文档，对于帮助文档大部分为纯文本文件，所以为了节省空间一般都是压缩存放，而man命令的作用就是找到对应的帮助文档然后解压缩后按着规定的样子进行显示。man的手册页在：/usr/share/man中存放。查看一下/usr/share/man中所存放的内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ ls /usr/share/man</span><br><span class="line">ca  de  fr  it  man0p  man1x  man3   man4   man5x  man7   man8x  mann       pt     sk  uk</span><br><span class="line">cs  en  hu  ja  man1   man2   man3p  man4x  man6   man7x  man9   overrides  pt_BR  sv  zh_CN</span><br><span class="line">da  es  id  ko  man1p  man2x  man3x  man5   man6x  man8   man9x  pl         ru     tr  zh_TW</span><br></pre></td></tr></table></figure><p>可以看到有man1-man9这样几个文件夹。</p><p>注意：有些命令在不止一个章节中存在帮助手册，要查看指定章节中的手册可以使用：<code>whatis COMMAND</code>来查看命令所存在的章节情况。例如查看read命令所在的man章节如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ whatis read</span><br><span class="line">read (1)             - bash built-in commands, see bash(1)</span><br><span class="line">read (1p)            - read a line from standard input</span><br><span class="line">read (2)             - read from a file descriptor</span><br><span class="line">read (3p)            - read from a file</span><br></pre></td></tr></table></figure><p>常用的章节为man1-man8，各个章节所存放的内容如下，可以使用ls命令查看各个文件夹下所包含的内容：</p><p>​    man1：用户命令<br>​    man2：系统调用<br>​    man3：库调用<br>​    man4：设备及特殊文件<br>​    man5：配置文件格式<br>​    man6：游戏<br>​    man7：杂项<br>​    man8：系统管理类命令</p><p>man搜寻对应命令的帮助文件和shell查找所要运行的命令的原理类似，对于man的查找也是需要规定它的查找路径的，它的配置文件为：/etc/man_db.conf 该文件的首部内容可以使用cat命令来查看内容如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> This file is used by the man-db package to configure the man and cat paths.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is also used to provide a manpath <span class="keyword">for</span> those without one by examining</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> their PATH environment variable. For details see the manpath(5) man page.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Lines beginning with `<span class="comment">#' are comments and are ignored. Any combination of</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tabs or spaces may be used as `whitespace<span class="string">' separators.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> There are three mappings allowed <span class="keyword">in</span> this file:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MANDATORY_MANPATH                     manpath_element</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MANPATH_MAP           path_element    manpath_element</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MANDB_MAP             global_manpath  [relative_catpath]</span></span><br><span class="line"><span class="meta">#</span><span class="bash">---------------------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> every automatically generated MANPATH includes these fields</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">MANDATORY_MANPATH                      /usr/src/pvm3/man</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">MANDATORY_MANPATH                       /usr/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/share/man</span><br><span class="line">MANDATORY_MANPATH                       /usr/local/share/man</span><br><span class="line"><span class="meta">#</span><span class="bash">---------------------------------------------------------</span></span><br></pre></td></tr></table></figure><p>在配置文件中定义了MANDATORY_MANPATH的全局变量，该全局变量定义了man寻找帮助文档的路径。如果要加入新的man位置可以在此增加MANPATH的路径，或使用命令：<code>man -M /PATH/TO/SOMEWHERE COMMAND</code>指定man命令到该指定的路径下搜索COMMAND命令的手册页并显示之。</p><p>使用man打开的帮助手册中的内容段落说明：</p><p>&emsp;&emsp;NAME:名称</p><p>&emsp;&emsp;SYSNOPSIS：命令的简要说明</p><p>&emsp;&emsp;&emsp;&emsp;[]:表示可选内容</p><p>&emsp;&emsp;&emsp;&emsp;&lt;&gt;:表示必选内容</p><p>&emsp;&emsp;&emsp;&emsp;a|b:二选一</p><p>&emsp;&emsp;&emsp;&emsp;…:同一内容可以出现多次</p><p>&emsp;&emsp;DESCRIPTION：命令的描述</p><p>&emsp;&emsp;OPTIONS：选项</p><p>&emsp;&emsp;EXAMPLES：例子</p><p>&emsp;&emsp;AUTHOR：作者</p><p>&emsp;&emsp;REPORTING BUGS：报告bug</p><p>&emsp;&emsp;SEE ALSO：也可以查看    </p><ol start="2"><li>info</li></ol><p>&emsp;&emsp;info COMMAND ：查看信息页</p><ol start="3"><li>程序自身的帮助文档</li></ol><p>&emsp;&emsp;对于程序自身的帮助文档一般会放在：/usr/share/doc/COMMAND-VERDION，所对应COMMAND的帮助文档，可以在此来查看关于该命令更多的帮助说明。</p><h2 id="Linux基础命令（三）"><a href="#Linux基础命令（三）" class="headerlink" title="Linux基础命令（三）"></a>Linux基础命令（三）</h2><h3 id="关于时间的命令"><a href="#关于时间的命令" class="headerlink" title="关于时间的命令"></a>关于时间的命令</h3><p>date命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">date [OPTION]... [+FORMAT]：显示时间</span><br><span class="line">date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]：设置时间</span><br></pre></td></tr></table></figure><p>FORMAT：用来显示的格式符号</p><p>&emsp;&emsp;%D:获取日期</p><p>&emsp;&emsp;%F:获取日期</p><p>&emsp;&emsp;%T:获取时间</p><p>命令效果如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ date +%D</span><br><span class="line">07/20/18</span><br><span class="line">[zhangshuo@localhost ~]$ date +%F</span><br><span class="line">2018-07-20</span><br><span class="line">[zhangshuo@localhost ~]$ date +%T</span><br><span class="line">10:52:19</span><br><span class="line">[zhangshuo@localhost ~]$ date +"This year is %Y.%nToday is %d."</span><br><span class="line">This year is 2018.</span><br><span class="line">Today is 20.</span><br><span class="line">[zhangshuo@localhost ~]$</span><br></pre></td></tr></table></figure><p>Linux的两种时钟：</p><p>&emsp;&emsp;系统时钟：由Linux内核通过CPU的工作频率进行的计时</p><p>&emsp;&emsp;硬件时钟：由板卡或是RTC硬件记录的时钟</p><p>查看硬件时钟的命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ sudo hwclock</span><br><span class="line">[sudo] password for zhangshuo: </span><br><span class="line">Fri 20 Jul 2018 10:57:00 AM CST  -0.035020 seconds</span><br><span class="line">[zhangshuo@localhost ~]$ sudo clock</span><br><span class="line">Fri 20 Jul 2018 10:57:06 AM CST  -0.684968 seconds</span><br></pre></td></tr></table></figure><p>注意：该命令需要管理员权限。</p><p>如果两个时钟不同步时可以使用：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hwclock -w :将系统时间同步到硬件时间</span><br><span class="line">hwclock -s :将硬件时间写入到系统时间</span><br></pre></td></tr></table></figure><p>查看日历的命令：</p><p><code>cal</code>可以查看当前的月历。使用如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ cal</span><br><span class="line">July 2018     </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">1  2  3  4  5  6  7</span><br><span class="line">8  9 10 11 12 13 14</span><br><span class="line">15 16 17 18 19 20 21</span><br><span class="line">22 23 24 25 26 27 28</span><br><span class="line">29 30 31</span><br></pre></td></tr></table></figure><p>也可以使用：<code>cal 2018</code>来查看年历</p><h3 id="目录相关的命令"><a href="#目录相关的命令" class="headerlink" title="目录相关的命令"></a>目录相关的命令</h3><p>对于家目录或主目录：</p><p>&emsp;&emsp;管理员的家目录为：/root</p><p>&emsp;&emsp;普通用户的家目录：/home/USERNAME  比如我的家目录为：/home/zhangshuo</p><p>&emsp;&emsp;~:表示用户的主目录。</p><p>cd命令：change directory 改变目录</p><p>&emsp;&emsp;使用cd或cd ~:回到当前用户的主目录</p><p>&emsp;&emsp;cd ~USERNAME:切换至指定用户的主目录（只有管理员才有进入其他用户主目录的权限）</p><p>&emsp;&emsp;cd -：在上一个目录和当前目录之间来回切换。（该技巧号称unux管理员惯用十大技巧之一）</p><p>相关的环境变量：</p><p>&emsp;&emsp;PWD：保存了当前工作目录的路径。可以使用 echo $PWD来查看此时PWD环境变量中所保存的内容。</p><p>&emsp;&emsp;OLDPWD：保存了上一次所在目录的路径。当然也可以使用echo来查看。</p><p>&emsp;&emsp;<code>pwd</code>命令可以显示当前目录的路径，使用如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost ~]$ pwd</span><br><span class="line">/home/zhangshuo</span><br></pre></td></tr></table></figure><p>ls命令：list 显示指定路径下的文件列表</p><p>&emsp;&emsp;ls [OPTION]… [FILE]…</p><p>&emsp;&emsp;&emsp;&emsp;-a,–all:显示所有文件，包括隐藏文件（以.开头的文件或文件夹）。</p><p>&emsp;&emsp;&emsp;&emsp;-l,–long:以长格式显示，比如</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost lftpfile]$ ll hexo.tar.bz2 </span><br><span class="line">-rw-rw-r--. 1 zhangshuo zhangshuo 105330699 Jul 18 09:55 hexo.tar.bz2</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;其中：-rw-rw-r–</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;最左侧的第一位表示：文件类型，Linux下的文件类型有：-(普通文件),d(目录文件),l(符号链接),b(块设备),c(字符设备),p(管道文件),s(套接字)。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;后面的9位表示：访问权限（perm）。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;数字1表示：文件被硬链接的次数。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;左侧的zhangshuo表示：文件的属主。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;右侧的zhangshuo表示：文件的属组。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;105330699表示：文件的大小。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;Jul 18 09:55表示：文件最近一次被修改的时间。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;hexo.tar.bz2表示：文件名。</p><p>&emsp;&emsp;&emsp;&emsp;-h：单位换算，以人类可读的方式显示。</p><p>&emsp;&emsp;&emsp;&emsp;-d：显示目录自身的相关属性，通常要与-l一起使用。使用该命令组合可以查看文件夹的大小。</p><p>&emsp;&emsp;&emsp;&emsp;-r,–reverse：逆序方式排列。</p><p>&emsp;&emsp;&emsp;&emsp;-R,–recursive:递归显示</p><h3 id="文件查看类命令-cat"><a href="#文件查看类命令-cat" class="headerlink" title="文件查看类命令 cat"></a>文件查看类命令 cat</h3><p>对于文件内容可以使用cat命令进行查看当然不止cat命令可以进行查看：cat - concatenate files and print on the standard output（链接并显示）</p><p>&emsp;&emsp;cat [OPTION]… [FILE]…</p><p>&emsp;&emsp;&emsp;&emsp;-E：显示行结束符。</p><p>&emsp;&emsp;&emsp;&emsp;-T：显示制表符。</p><p>&emsp;&emsp;&emsp;&emsp;-v：显示非打印字符。</p><p>&emsp;&emsp;&emsp;&emsp;-n：显示行号。</p><h3 id="文件内容类型查看命令-file"><a href="#文件内容类型查看命令-file" class="headerlink" title="文件内容类型查看命令 file"></a>文件内容类型查看命令 file</h3><p>命令：file /PATH/TO/SOMEFILE 即可查看文件内容所属类型，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost lftpfile]$ file id_rsa.pub </span><br><span class="line">id_rsa.pub: OpenSSH RSA public key</span><br><span class="line">[zhangshuo@localhost lftpfile]$ file /etc/passwd</span><br><span class="line">/etc/passwd: ASCII text</span><br><span class="line">[zhangshuo@localhost lftpfile]$ file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=c5ad78cfc1de12b9bb6829207cececb990b3e987, stripped</span><br></pre></td></tr></table></figure><h3 id="回显命令-echo"><a href="#回显命令-echo" class="headerlink" title="回显命令 echo"></a>回显命令 echo</h3><p>echo - display a line of text：显示一行文字</p><p>&emsp;&emsp;-n：禁止自动添加换行符。</p><p>&emsp;&emsp;-e：允许使用转义字符。</p><p>使用实例如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zhangshuo@localhost lftpfile]$ echo "how are you"</span><br><span class="line">how are you</span><br><span class="line">[zhangshuo@localhost lftpfile]$ echo -n "how are you"</span><br><span class="line">how are you[zhangshuo@localhost lftpfile]$ echo -e "how \n are you.\nhow old are you"</span><br><span class="line"> how </span><br><span class="line">are you.</span><br><span class="line">how old are you</span><br><span class="line">[zhangshuo@localhost lftpfile]$ echo "$PATH" #若引用，变量将以存储的内容显示</span><br><span class="line">/home/zhangshuo/.npm-global/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/usr/local/node/bin:/home/zhangshuo/.local/bin:/home/zhangshuo/bin</span><br><span class="line">[zhangshuo@localhost lftpfile]$ echo '$PATH' #强引用，直接引用不显示变量的值</span><br><span class="line"><span class="meta">$</span><span class="bash">PATH</span></span><br></pre></td></tr></table></figure><h3 id="系统管理类命令"><a href="#系统管理类命令" class="headerlink" title="系统管理类命令"></a>系统管理类命令</h3><p>关机：</p><p>&emsp;&emsp;halt，poweroff，shutdown -h now，init 0</p><p>重启：</p><p>&emsp;&emsp;reboot，shutdown -r now，init 6</p><p>用户登陆相关：</p><p>&emsp;&emsp;who，whoami，w</p><p>-EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第2集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;OS Linux发行版，Linux系统基础使用入门，Linux命令帮助&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>小红帽第1集</title>
    <link href="https://zhangdashuo.github.io/2018/07/17/redhat01/"/>
    <id>https://zhangdashuo.github.io/2018/07/17/redhat01/</id>
    <published>2018-07-17T02:53:18.000Z</published>
    <updated>2018-07-27T13:33:20.163Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 小红帽第1集：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>操作系统及Linux的基础知识<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="操作系统及Linux基础知识"><a href="#操作系统及Linux基础知识" class="headerlink" title="操作系统及Linux基础知识"></a>操作系统及Linux基础知识</h2><h3 id="现代计算机设备的组成部分"><a href="#现代计算机设备的组成部分" class="headerlink" title="现代计算机设备的组成部分"></a>现代计算机设备的组成部分</h3><p>现代计算机的构架主要还是在冯诺·依曼架构之上完成的。主要由运算器、控制器、存储设备、输入设备和输出设备。在现代的制造工艺中将运算器与控制器集成在一片芯片之上叫做CPU。CPU又叫做中央处理器，是计算机的核心部分。同时CPU不是单独自己工作的它又需要与外界进行数据交互，与外界进行的数据交互是通过总线来进行数据的传输的。计算机中的总线有控制总线，数据总线，和地址总线。所谓总线（Bus），是指计算机设备和设备之间传输信息的公共数据通道。总线是连接计算机硬件系统内多种设备的通信线路，它的一个重要特征是由总线上的所有设备共享，可以将计算机系统内的多个部件连接到总线上进行通讯。如果是某两个设备或设备之间专用的信号连线，就不能称之为总线。微机中的总线分为数据总线、地址总线和控制总线3类。不同型号的CPU芯片，其数据总线、地址总线和控制总线的条数可能不同。  数据总线DB用来传送数据信息，是双向的。CPU既可通过DB从内存或输入设备读入数据，又可通过DB将内部数据送至内存或输出设备。DB的宽度决定了CPU和计算机其他设备之间每次交换数据的位数。  地址总线AB用于传送CPU发出的地址信息，是单向的。传送地址信息的目的是指明与CPU交换信息的内存单元或I/O设备。内存是编址的存储单元，所以每个存储单元都有一个固定地址，对于内存来说每8个字节叫做一个cell，要访问1MB存储器中的任一单元，需要给出1M个地址，即需要10位地址（2^10=1M）。因此，地址总线的宽度决定了CPU的最大寻址能力。  控制总线CB用来传送控制信号、时序信号和状态信息等。其中有的是CPU向内存或外部设备发出的信息，有的是内存或外部设备向CPU发出的信息。显然，CB中的每一条线的信息传送方向是一定的、单向的，但作为一个整体则是双向的。所以，在各种结构框图中，凡涉及到控制总线CB，均是以双向线表示。  总线的性能直接影响到整机系统的性能，而且任何系统的研制和外围模块的开发都必须依从所采用的总线规范。总线技术随着微机结构的改进而不断发展与完善。可见地址总线决定来CPU寻址的范围，由此可以看出对于32位的操作系统来说内存的最大寻址范围为32位也就是2的32位次方，也就是4G，由此对于32的计算机来说最大可识别内存也就是4G，对于64位操作系统来说也就是2的64方也就是4G个4G内存范围。</p><h3 id="程序运行的局部性原理"><a href="#程序运行的局部性原理" class="headerlink" title="程序运行的局部性原理"></a>程序运行的局部性原理</h3><p>在程序运行时操作系统会为程序提供内存空间来运行需要执行的程序，在现在的计算机中通常CPU的运行速度要远快与IO设备，对于我的硬件来说我的CPU的运行速度为2.5GHZ但对于内存来说笔记本的内存速度也就是1600MHZ可见内存的速度要远低于CPU的运行速度。为了解决程序运行效率问题加入来缓存机制，缓存的速度是接近CPU的速度的，所以在CPU中会有一级缓存二级缓存和三级缓存，离CPU越近速度越快，但是成本就越高，这就是计算机的折中机制。这里说一下对于计算机的扩展有两种方式一种横向扩展一种纵向扩展横向扩展指的是用多个性能普通的计算机进行组合为一个功能强大的集群来完成复杂的计算功能，而纵向扩展指的是通过提过当个计算机的硬件性能，比如提高CPU的主频，增加内存，使用固态硬盘等方式来增加单个计算的计算性能。通常这种纵向扩展的方式性价比不高。程序界有一种说法为缓存为王，即cache is king 之所以这样说是因为程序运行时会遵循局部性原理，局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。根据程序的局部性原理我们就可以提前将需要的数据放入缓存中，这样便可以提高计算机的运行效率。</p><h3 id="计算机的I-O设备"><a href="#计算机的I-O设备" class="headerlink" title="计算机的I/O设备"></a>计算机的I/O设备</h3><p>刚说到CPU不是独自工作的，需要与外界设备进行交换，通常这些外部设备就为IO设备。计算机中常见的IO设备有硬盘，网卡，键盘，鼠标，显示器等。</p><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。虚拟机的结构如下</p><p><img src="/2018/07/17/redhat01/xunijijiegou.png" alt=""></p><p>对于cpu的虚拟化：其实在现代操作系统结构下cpu就是虚拟化的通过划分时间片的方式来进行任务或是程序的处理。对于cpu的虚拟化只需要指令能够提交给cpu进行运行就行。</p><p>内存的虚拟化：现代操作系统对于内存的使用是采用线性地址空间的方式进行数据的存储的。这中内存的使用方式可以提高系统的安全性能。</p><h2 id="Linux基础入门"><a href="#Linux基础入门" class="headerlink" title="Linux基础入门"></a>Linux基础入门</h2><h3 id="CPU中央处理器"><a href="#CPU中央处理器" class="headerlink" title="CPU中央处理器"></a>CPU中央处理器</h3><p>CPU由运算器和控制器组成，通常CPU要完成哪些运算，和其运算能力是根据其所支持的指令操作来完成的，这些CPU可用的指令叫做指令集。通常不同生厂商生产的CPU的指令集是不同的。（如果要查看自己CPU所支持的指令集可以使用 cat /proc/cpuinfo 命令查看自己CPU的相关信息）。在CPU设计时将CPU可运行的指令分成了四个环，通常我们叫做环0环1环2环3。CPU的环形结构如下：</p><p><img src="/2018/07/17/redhat01/CPUring.png" alt=""></p><p>环3上只能运行普通指令，而环0上运行的为特权指令，通常我们把运行在环3上的指令叫做用户空间或是用户模式，把运行在环0上的指令叫做内核空间或是内核模式。这样做是为了提高系统的安全性能，因为只有操作系统才可以运行特权指令。而普通用户的程序只能在环3上运行也就是之能运行普通指令，由于历史的原因环1和环2没有使用。有同学会说普通户也需要运行特权指令啊，比如新建文件等需要进行IO操作的指令等，是的没错普通用户是需要运行特权指令，但是当普通用户需要运行特权指令时会向操作系统发出请求即系统调用让操作系统帮忙来完成所需要的操作。对于程序中的系统调用的切换模式如图所示：</p><p><img src="/2018/07/17/redhat01/qiehuan.jpg" alt=""></p><p>当用户需要使用特权指令时就会向操作系统发出系统调用此时有操作系统代为执行所需的指令来完成某些所需的特权操作。</p><h3 id="CPU的架构类型"><a href="#CPU的架构类型" class="headerlink" title="CPU的架构类型"></a>CPU的架构类型</h3><p>记得一次上课老师问计算机的构架是什么有同学说X86有同学说X64等等，其实这些都是概念没有搞清楚。当代计算机都还没有打破冯诺.依曼的架构。这里说CPU的架构吧，当前PC机中的CPU架构有X86即32位的CPU，X64即64位CPU，对于X86_64结构是英特尔和AMD兼容的CPU结构类型。还有现代比较流行的人手一个的手持智能终端设备中用的ARMCPU，这种ARM架构的CPU最大的特点就是省电，ARM这个公司很诡异，这个公司只卖版权，不生产CPU，生产是由高通，三星等这些公司。还有一些早些比较强悍的CPU比如moto公司的M68000,IBM的powerCPU，powerCPU是世界上第一个多核心第一个8核第一个16核，第一个主频突破4GHZ的CPU，但是IBM的制造工艺没有INTEL公司的制造工艺先进。还有简装版的power叫做powerPC的CPU，该CPU是由苹果，摩托罗拉，和IBM三家联合设计研发的CPU，这个CPU性能也很不错，当时苹果公司的电脑用的都是powerPC，因为CPU的指令集不同，所以早些时候MAC操作系统无法在普通的PC机上运行，后来INTEL公司的CPU性能慢慢也很不错，所以现在苹果公司用的也是intel的CPU，这也就导致了很多黑苹果的诞生。</p><h3 id="操作系统（OS-Operating-System）"><a href="#操作系统（OS-Operating-System）" class="headerlink" title="操作系统（OS:Operating System）"></a>操作系统（OS:Operating System）</h3><p>操作系统是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件。说白了操作系统就是一个软件程序，但是这个软件程序是出于通用目将底层硬件的接口抽象出来的来提供硬件驱动、进程管理、内存管理、网络管理、安全管理等功能的通用软件。<br>当前主流的操作系统有windows，Linux，Unix等。<br>Windows是每个人都接触过的操作系统，这里就不多说了，但是这个系统属于那种入门简单鼠标点一点感觉很轻松但是深入却很难的一套操作系统。算算接触Windows也快20年了也就会操作系统的安装，软件的安装，Ctrl+Alt+Delete结束进程等很简单的操作。<br>Unix可以说是世界操作系统的鼻祖，如果有兴趣可以查一查关于windows是如何从乔布斯那里抄袭创意和乔布斯如何从Park实验室那里抄袭。可以看出伟大的人的创意都是抄袭的。Unix有两个重要分支，其中嫡出系统叫做system风格的Unix是由Bell实验室研发的。属于system风格的操作系统还有IBM公司的AIX，SUN公司的Solaris，HP公司的HP-UX等，另一个分支叫做庶出也就是小老婆生的叫做BSD，是由伯克利研究小组（BSRG）进行研发的叫做Berkeley System Distribution。其中基于BSD的流行的系统有<strong>NETBSD</strong>,<strong>OPENBSD</strong>,<strong>FREEBSD</strong>等。我们生活中对Unix不常见的原因在于Unix通常叫做贵族操作系统，之所以这样说是因为UNIX通常是在小型机上跑的操作系统，而一台小型机怎么也要二三十万左右的样子，不像Linux在2000块钱的主机上都可以跑的飞起。<br>在嫡出和庶出打仗的时候unix是收费的此时由MIT的Richard Stallman发起了软件共产主义运动，即GNU（GUN is not Unix）组织，和共产主义宣言即GPL（General Public License）协定。GNU组织的成立主要是因为UNIX从开源变为收费为了摆脱UNIX而成立的组织，但当时GNU叫做GUN is not Unix但是该组织中的开源程序还是基于Unix的这就陷入了一个尴尬的环境，此时GNU迫切需要一个自己的操作系统，就在此时1991年Linus的linux诞生了，当linux碰到GNU那就是山无棱,天地合,才敢与君绝，一拍即合。所以linux发展速度很快。Linux内核由1991的0.01版本迅速发展在1994年就发行了1.0版本。可见Linux的发展的迅速的。如果要查看最新内核的版本情况  <a href="https://www.kernel.org/" target="_blank" rel="noopener">点击这里</a> 。小时候看黑客帝国的时候就看的是大战母体的打斗的场景，那会还不了解Linux其实现在接触Linux才发现那是里面好多的工具都是我们常用的运维工具，比如matrix也就是母体用的Linux内核就是6.4版本的。</p><h3 id="操作系统的层次结构"><a href="#操作系统的层次结构" class="headerlink" title="操作系统的层次结构"></a>操作系统的层次结构</h3><p>操作系统的层级结构如下：</p><p><img src="/2018/07/17/redhat01/oscengjijiegou.png" alt=""></p><p>从操作系统的层级结构下来说编程层次：</p><p>程序员面对的编程对象不同分为如下：</p><blockquote><ul><li>硬件规格 ：hardware specifiacation</li><li>系统调用：目前linux内核支持的系统调用有400多个的样子</li><li>库调用：library call</li></ul></blockquote><p>对于操作系统来说肯定还会和人进行交互，此时操作系统就需要有用户交互程序，通常这个程序叫做shell是内核的壳程序。用户交互程序叫做UI：user interface 目前对于UI主要有两种风格，一种基于图形界面的典型代表为windows下的交互程序。这种交互程序叫做GUI(也有人叫做鬼谐音而已)：Graphic User Interface。另一种是基于命令行的交互程序，那就是Linux代表的一类接口。叫做CLI：Command Line Interface 。其实对于命令行接口来说可能入门较难但是效率通常会比图形界面下的执行效率要高很多。</p><hr><p>—EOF</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 小红帽第1集：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;操作系统及Linux的基础知识&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小红帽" scheme="https://zhangdashuo.github.io/categories/%E5%B0%8F%E7%BA%A2%E5%B8%BD/"/>
    
    
      <category term="Linux" scheme="https://zhangdashuo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>新的环境，新的博客</title>
    <link href="https://zhangdashuo.github.io/2018/07/13/hello-world/"/>
    <id>https://zhangdashuo.github.io/2018/07/13/hello-world/</id>
    <published>2018-07-13T14:29:37.000Z</published>
    <updated>2018-07-18T06:13:33.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong> 新的环境，新的博客：</strong> <excerpt in="" index="" |="" 首页摘要=""><br>我的博客说明<br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="关于我的第一篇博客"><a href="#关于我的第一篇博客" class="headerlink" title="关于我的第一篇博客"></a>关于我的第一篇博客</h2><p>去年十一月份无意中发现了云主机技术，正好学习Linux系统管理，所以很快就申请了云主机进行Centos环境的服务系统的模拟，当然我知道这不是生产环境，没有生产环境的压力。但是对于我这样业余Linux爱好者来说已经可以满足了。申请主机之后感觉总要运行一下什么服务啥的，后来看到好多技术人员都有写博客的习惯，因为博客可以记录自己配置过程的问题让更多的人少走弯路或者对于自己学习的过程的记录。所以申请域名在主机上运行了第一个服务就是博客服务。当时用的博客系统是FireKylin博客系统，之所以采用这个系统是因为它的简介明了，通过网页后台进行博客的管理和文章的书写。原博客地址  <a href="http://www.zhangshuocauc.cn/" target="_blank" rel="noopener">点击这里</a> ，从此开始了我的博客之旅。</p><h2 id="对于原博客的说明"><a href="#对于原博客的说明" class="headerlink" title="对于原博客的说明"></a>对于原博客的说明</h2><p> 对于原博客写的文章是关于嵌入式系统和Linux的有关知识的文章，我初步打算将Linux和嵌入式的文章进行分开，原博客将主要书写关于嵌入式系统或是其他有关的内容的文章。而新博客将主要书写关于Linux系统管理有关的文章。</p><h2 id="搭建新博客的原因"><a href="#搭建新博客的原因" class="headerlink" title="搭建新博客的原因"></a>搭建新博客的原因</h2><p> 对于FireKylin有它的优点，但是由于它的用户较少和没有活跃的社区，同时没有可以自由选择的皮肤而hexo博客就不一样，拥有相当多的用户和可以自由选择自己喜欢的皮肤，同时它可以部署在github上减少了主机的成本，所以打算投入hexo的怀抱。</p><h2 id="我的新博客"><a href="#我的新博客" class="headerlink" title="我的新博客"></a>我的新博客</h2><p> 经过几天的折腾安装hexo(Centos操作系统)，配置，更换主题，修改主题，安装插件等一系列配置最终搭建完成  新博客地址 <a href="https://zhangdashuo.github.io/">点击这里</a> 对于新博客主要是对我学习Linux管理的记录和分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt; 新的环境，新的博客：&lt;/strong&gt; &lt;excerpt in=&quot;&quot; index=&quot;&quot; |=&quot;&quot; 首页摘要=&quot;&quot;&gt;&lt;br&gt;我的博客说明&lt;br&gt;&lt;/excerpt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://zhangdashuo.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="https://zhangdashuo.github.io/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
